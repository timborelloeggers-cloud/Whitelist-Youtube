<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>YouTube Whitelist V8.3 (Permissions Fix)</title>
  
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

  <style>
    :root{
      --bg:#0f0f0f; --card:#1a1a1a; --muted:#b8b8b8; --text:#fff;
      --accent:#ff0033; --radius:18px; --shadow:0 10px 24px rgba(0,0,0,.35)
    }
    
    /* Text Mode Variations */
    body.text-light {
      --text:#1a1a1a; --muted:#666666; --card-overlay:rgba(0,0,0,0.05);
    }
    body.text-dark {
      --text:#ffffff; --muted:#b8b8b8; --card-overlay:rgba(255,255,255,0.05);
    }
    body.text-light header { background:rgba(255,255,255,.6); border-bottom:1px solid rgba(0,0,0,.1); backdrop-filter: blur(12px); }
    body.text-light .btn { background:rgba(232,232,232,0.7); color:#1a1a1a; border-color:rgba(208,208,208,0.6); transition: all 0.2s ease; backdrop-filter: blur(8px); }
    body.text-light .btn:hover { background:rgba(216,216,216,0.85); color:#000; }
    body.text-light .btn.active { background:var(--accent); color:#fff; border-color: var(--accent); }
    body.text-light .searchbar { 
        background:rgba(255,255,255,0.5); border-color:rgba(0,0,0,0.1); 
        color:#1a1a1a; backdrop-filter: blur(12px);
    }
    body.text-light .searchbar input { 
        color:#1a1a1a; background:rgba(255,255,255,0.4); 
        border-color:rgba(0,0,0,0.1);
    }
    body.text-light .searchbar input::placeholder { color: rgba(0,0,0,0.5); }
    body.text-light .tab { 
        background:rgba(232,232,232,0.7); border-color:rgba(208,208,208,0.6);
        backdrop-filter: blur(10px);
    }
    body.text-light .tab:hover { background:rgba(216,216,216,0.85); }
    body.text-light .side-menu { background:rgba(255,255,255,0.5); backdrop-filter: blur(12px); border-left-color:rgba(0,0,0,0.1); }
    body.text-light .skeleton { background:linear-gradient(90deg, #e8e8e8 25%, #f0f0f0 50%, #e8e8e8 75%); }
    body.text-light .tab { background:#e8e8e8; border-color:#d0d0d0; color:#1a1a1a; transition: all 0.2s ease; }
    body.text-light .tab:hover { background:#d8d8d8; }
    body.text-light .tab.active { background:var(--accent); color:#fff; border-color: var(--accent); }
    body.text-light .loadmore { 
        background: rgba(255,255,255,0.5); 
        backdrop-filter: blur(12px);
        color:#1a1a1a; 
        border-color:rgba(0,0,0,0.1); 
        transition: all 0.2s ease; 
    }
    body.text-light .loadmore:hover { 
        background: rgba(255,255,255,0.65); 
        border-color:rgba(0,0,0,0.2); 
    }
    body.text-light .modal { background:rgba(255,255,255,0.5); backdrop-filter: blur(20px); border-color:rgba(0,0,0,0.1); color:#1a1a1a; }
    body.text-light .modal-header { border-bottom-color:rgba(0,0,0,0.1); color:#1a1a1a; }
    body.text-light .modal-header .btn { color:#1a1a1a; }
    body.text-light footer { border-top-color:#d0d0d0; color:#666; }
    body.text-light.has-bg-image footer a { color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    body.text-light.has-bg-image footer a:hover { color: #f0f0f0; }
    body.text-light .setting-group { background:rgba(255,255,255,0.5); backdrop-filter: blur(12px); border-color:rgba(0,0,0,0.1); }
    body.text-light .setting-label { color:#1a1a1a; }
    body.text-light .setting-hint { color:#666; }
    body.text-light .toggle-btn { background:rgba(255,255,255,0.5); backdrop-filter: blur(12px); border-color:rgba(0,0,0,0.1); color:#1a1a1a; }
    body.text-light .toggle-btn:hover { background:rgba(255,255,255,0.65); }
    body.text-light .toggle-btn.active { background:var(--accent); border-color: var(--accent); color:#fff; }

    .duration-adjuster-container {
      margin-top: 20px;
    }
    .duration-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 10px;
    }
    .duration-btn {
      font-size: 1.5rem;
      font-weight: bold;
      padding: 0;
      width: 40px;
      height: 40px;
      line-height: 40px;
      text-align: center;
    }
    .duration-display {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
      min-width: 100px;
      text-align: center;
    }
    body.text-light .duration-display {
        color: #1a1a1a;
    }
    body.text-light .menu-links { border-top-color:#d0d0d0; }
    body.text-light .menu-link { color:#1a1a1a; }
    body.text-light .menu-link:hover { background:rgba(0,0,0,0.05); }
    body.text-light .text-page { color:#1a1a1a; }
    body.text-light .text-page h2, body.text-light .text-page h3 { color:#1a1a1a; border-bottom-color:#d0d0d0; }
    body.text-light .text-page p, body.text-light .text-page ul { color:#333; }
    body.text-light .text-page a { color:#0066ff; }
    body.text-light .text-content {
        background: rgba(255,255,255,0.5);
        border: 1px solid rgba(0,0,0,0.1);
    }
    body.text-light .searchbar {
        background: rgba(255,255,255,0.5);
        border: 1px solid rgba(0,0,0,0.1);
    }
    body.text-light .searchbar input {
        background: rgba(255,255,255,0.6);
        border: 1px solid rgba(0,0,0,0.1);
        color: #1a1a1a;
    }
    body.text-light .searchbar input::placeholder {
        color: rgba(0,0,0,0.5);
    }
    body.text-light .searchbar input:focus {
        background: rgba(255,255,255,0.8);
    }
    body.text-light .page-header {
        background: rgba(255,255,255,0.5);
        border: 1px solid rgba(0,0,0,0.1);
    }
    body.text-light .page-header h2 {
        color: #1a1a1a;
    }
    body.text-light .video-card, body.text-light .chan-card { 
        background:rgba(255,255,255,0.5); border-color:rgba(0,0,0,0.1); 
        backdrop-filter: blur(12px);
    }
    body.text-light .video-card:hover, body.text-light .chan-card:hover { 
        box-shadow: 0 15px 35px rgba(0,0,0,.15); 
        background:rgba(255,255,255,0.65);
    }
    body.text-light .thumb { background:#e8e8e8; }
    body.text-light .chan-thumb { background:#e8e8e8; }
    body.text-light .chip { background:rgba(255,255,255,.9); color:#1a1a1a; }
    
    *{box-sizing:border-box}
    html,body{height:100%; overflow-x: hidden;}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text); transition: background-color 0.3s ease, color 0.3s ease;}
    .hidden { display: none !important; }
    header{position:sticky;top:0;z-index:100;backdrop-filter:saturate(140%) blur(12px);background:rgba(10,10,10,.5);border-bottom:1px solid rgba(255,255,255,.06); transition: background 0.3s ease;}
    .topbar{max-width:1200px;margin:0 auto;padding:.6rem .75rem;display:flex;gap:.5rem;align-items:center;justify-content:space-between;}
    .topbar-left{display:flex;gap:.5rem;align-items:center;}
    .topbar-right{display:flex;gap:.5rem;align-items:center;}
    .btn{border:none;background:rgba(37,37,37,0.7);color:#eee;border:1px solid rgba(47,47,47,0.6);padding:.45rem .8rem;border-radius:999px;cursor:pointer;font-size:.9rem;white-space:nowrap; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; backdrop-filter: blur(8px);}
    .btn:hover{transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3);}
    .btn:active{transform: translateY(0);}
    .loadmore {
        background: rgba(15,15,15,0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 16px 32px;
        font-size: 1.05rem;
        font-weight: 600;
        margin: 20px auto;
        display: block;
        width: fit-content;
        min-width: 250px;
        border-radius: 12px;
        color: #fff;
    }
    .loadmore:hover {
        background: rgba(37,37,37,0.85);
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        border-color: rgba(255,255,255,0.2);
    }
    .btn.active{background:var(--accent);border-color:transparent;color:#fff}
    #refreshBtn.loading svg { animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    main{max-width:1200px;margin:0 auto;padding:12px; padding-bottom: 60px;}
    .section{margin-top:14px; animation: fadeIn 0.3s ease-in-out;}
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .section h2{
        font-size:1.05rem;margin:.25rem 4px; transition: all 0.3s ease;
        text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.6);
        padding: 12px 16px;
        background: rgba(15,15,15,0.5);
        backdrop-filter: blur(12px);
        border-radius: 12px;
        display: inline-block;
        border: 1px solid rgba(255,255,255,0.1);
    }
    body.text-light .section h2{
        text-shadow: 0 2px 8px rgba(255,255,255,0.9), 0 0 20px rgba(255,255,255,0.7);
        background: rgba(255,255,255,0.5);
        border: 1px solid rgba(0,0,0,0.1);
    }
    .grid{display:grid;gap:12px}
    .grid.cols-channels{grid-template-columns:repeat(auto-fill,minmax(140px,1fr));}
    .grid.cols-vids{grid-template-columns:repeat(auto-fill,minmax(280px,1fr))}
    
    @media (max-width: 480px) {
        .grid.cols-channels{grid-template-columns:repeat(2,1fr);}
    }
    
    .chan-card{
        background:rgba(15,15,15,0.5);border:1px solid rgba(255,255,255,0.1);border-radius:var(--radius);
        overflow:hidden;box-shadow:var(--shadow);padding:12px;
        backdrop-filter: blur(12px);
        display:flex; flex-direction: column; gap:8px; align-items:center; text-align:center; cursor:pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .chan-card:hover{transform: translateY(-4px); box-shadow: 0 15px 35px rgba(0,0,0,.45); background:rgba(20,20,20,0.7);}
    .chan-thumb{width:48px;height:48px;border-radius:50%;background:#2b2b2b;overflow:hidden;flex:0 0 auto}
    .chan-thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .chan-meta{display:flex;flex-direction:column;gap:2px}
    .chan-title{font-weight:700; font-size: 0.9rem;color:var(--text)}
    .chan-card .sub { font-size: 0.8rem;color:var(--muted) }

    .video-card{
        background:rgba(15,15,15,0.5);border:1px solid rgba(255,255,255,0.1);
        border-radius:calc(var(--radius) + 2px);overflow:hidden;box-shadow:var(--shadow); 
        backdrop-filter: blur(12px);
        cursor:pointer; transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .video-card:hover{transform: translateY(-4px); box-shadow: 0 15px 35px rgba(0,0,0,.45); background:rgba(20,20,20,0.7);}
    .thumb{position:relative;aspect-ratio:16/9;background:#222; overflow:hidden;}
    .thumb img{transition: transform 0.3s ease;}
    .video-card:hover .thumb img{transform: scale(1.05);}
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .progress-bar-container{position:absolute;bottom:0;left:0;right:0;height:4px;background:rgba(255,255,255,0.2)}
    .progress-bar{height:100%;width:0%;background:var(--accent)}
    .chip{position:absolute;bottom:8px;right:8px;background:rgba(0,0,0,.7);color:#fff;border-radius:4px;padding:.2rem .5rem;font-size:.75rem}
    .add-to-list-btn{
        position:absolute;top:8px;left:8px;
        width:32px;height:32px;border-radius:50%;
        background:rgba(0,0,0,0.7);border:2px solid rgba(255,255,255,0.3);
        color:#fff;cursor:pointer;
        display:flex;align-items:center;justify-content:center;
        transition:all 0.2s ease;
        backdrop-filter:blur(8px);
        z-index:10;
    }
    .add-to-list-btn:hover{background:rgba(0,0,0,0.9);border-color:#4CAF50;transform:scale(1.1);}
    .add-to-list-btn.added{background:#4CAF50;border-color:#4CAF50;transform:rotate(45deg);}
    .add-to-list-btn.added:hover{background:#45a049;}
    .mark-watched-btn{
        position:absolute;top:8px;right:8px;
        width:32px;height:32px;border-radius:50%;
        background:rgba(0,0,0,0.7);border:2px solid rgba(255,255,255,0.3);
        color:#fff;cursor:pointer;
        display:flex;align-items:center;justify-content:center;
        transition:all 0.2s ease;
        backdrop-filter:blur(8px);
        z-index:10;
    }
    .mark-watched-btn:hover{background:rgba(0,0,0,0.9);border-color:var(--accent);transform:scale(1.1);}
    .mark-watched-btn.watched{background:var(--accent);border-color:var(--accent);}
    .mark-watched-btn.watched:hover{background:#cc0033;}
    .card-body{padding:10px 12px;display:flex;flex-direction:column;gap:6px}
    .title{font-weight:700;font-size:.98rem;line-height:1.25;color:var(--text)}
    .meta{color:var(--muted);font-size:.85rem; display: flex; justify-content: space-between;}
    .tabs{
        display: flex;
        gap: 8px;
        margin: 0 0 16px 0;
    }
    .tab{
        padding: 12px 24px;
        border-radius: 10px;
        background: rgba(15,15,15,0.5);
        border: 1px solid rgba(255,255,255,0.1);
        cursor: pointer;
        transition: all 0.2s ease;
        backdrop-filter: blur(12px);
        font-size: 0.95rem;
        font-weight: 500;
    }
    .tab:hover { background: rgba(37,37,37,0.7); transform: translateY(-2px); }
    .tab.active{
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
        box-shadow: 0 4px 12px rgba(255,0,51,0.3);
    }
    
    /* Channel Banner */
    #channelName { 
        font-size: 1.8rem; 
        font-weight: 700; 
        color: var(--text);
        text-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    #channelBannerContainer { 
        position: relative; 
        width: 100%; 
        height: 200px; 
        overflow: hidden; 
        border-radius: 12px; 
        margin: 0 0 16px 0;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    }
    #channelBannerBackground { 
        position: absolute; 
        inset: 0; 
        background-size: cover; 
        background-position: center;
        filter: blur(15px) brightness(0.5);
        transform: scale(1.15);
    }
    
    .searchbar{
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 10px;
        background: rgba(15,15,15,0.5);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        margin: 0 0 12px 0;
        transition: all 0.2s ease;
        backdrop-filter: blur(12px);
    }
    .searchbar input{
        flex: 1;
        background: rgba(0,0,0,0.4);
        border: 1px solid rgba(255,255,255,0.1);
        color: #fff;
        outline: none;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        padding: 10px 14px;
        border-radius: 8px;
        min-width: 0;
    }
    .searchbar input::placeholder { color: rgba(255,255,255,0.5); }
    .searchbar input:focus { border-color: var(--accent); background: rgba(0,0,0,0.5); }
    .searchbar .btn { 
        padding: 10px 16px; 
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        flex-shrink: 0;
    }
    .searchbar .btn svg { margin: 0; }
    #clearSearchBtn {
        padding: 10px 12px;
        background: rgba(255,0,51,0.2);
        border-color: var(--accent);
    }
    #clearSearchBtn:hover {
        background: var(--accent);
    }
    
    /* Mobile: Kleinere Buttons in Suchzeile */
    @media (max-width: 480px) {
        .searchbar .btn {
            padding: 8px 12px;
            font-size: 0.85rem;
        }
        #clearSearchBtn {
            padding: 8px 10px;
        }
        .sort-options .btn {
            padding: 6px 10px;
            font-size: 0.8rem;
        }
    }
    .sort-options{
        display: flex;
        gap: 6px;
        width: 100%;
        padding: 8px 0 0 0;
        animation: slideDown 0.3s ease;
        flex-wrap: wrap;
    }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    .sort-options .btn { padding: 8px 14px; font-size: 0.85rem; transition: all 0.2s ease; }
    .overlay { position:fixed;inset:0;background:rgba(0,0,0,.75);backdrop-filter:blur(8px);display:none;align-items:center;justify-content:center;z-index:200; animation: fadeIn 0.2s ease; }
    .overlay.show{display:flex}
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .modal{
        width:96%;max-width:1400px;max-height:90vh;margin:auto;
        background:rgba(15,15,15,0.5);border:1px solid rgba(255,255,255,0.1);
        border-radius:16px;overflow:hidden;box-shadow:0 20px 40px rgba(0,0,0,.7);
        display:flex;flex-direction:column; animation: slideUp 0.3s ease;
        backdrop-filter: blur(20px);
    }
    @keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    .modal-header{display:flex;justify-content:space-between;align-items:center;padding:1rem 1.5rem;border-bottom:1px solid rgba(255,255,255,0.1);backdrop-filter:blur(12px);}
    .modal-body{flex:1;overflow-y:auto;position:relative;}
    #player-mount{width:100%;aspect-ratio:16/9;background:#000;}
    details { 
        border: 1px solid rgba(255,255,255,0.1); 
        border-radius: var(--radius); 
        margin-top: 1rem; 
        transition: all 0.3s ease;
        background: rgba(15,15,15,0.3);
        backdrop-filter: blur(12px);
    }
    details[open] { background: rgba(15,15,15,0.3); }
    summary { 
        cursor: pointer; padding: 1rem; font-weight: bold; transition: all 0.2s ease;
        background: transparent;
        text-shadow: 0 2px 6px rgba(0,0,0,0.8);
        border-radius: var(--radius);
    }
    summary:hover { background-color: rgba(255,255,255,0.05); }
    body.text-light details {
        border: 1px solid rgba(0,0,0,0.1);
        background: rgba(255,255,255,0.3);
        backdrop-filter: blur(12px);
    }
    body.text-light details[open] { 
        background: rgba(255,255,255,0.3); 
        backdrop-filter: blur(12px);
    }
    body.text-light summary {
        background: transparent;
        text-shadow: 0 2px 6px rgba(255,255,255,0.9);
        color: #1a1a1a;
    }
    body.text-light summary:hover { 
        background-color: rgba(0,0,0,0.05); 
    }
    .details-content { padding: 0 1rem 1rem 1rem; animation: slideDown 0.3s ease; }
    .side-menu {
        position: fixed;
        top: 0;
        right: 0;
        width: 280px;
        height: 100%;
        background: rgba(15,15,15,0.5);
        backdrop-filter: blur(12px);
        border-left: 1px solid rgba(255,255,255,0.1);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        z-index: 300;
        padding: 40px 20px;
        display: flex;
        flex-direction: column;
    }
    .side-menu.open { transform: translateX(0); }
    .side-menu .auth-container { 
        display: flex;
        flex-direction: column; 
        align-items: center; 
        gap: 15px; 
        margin-left: 0; 
        text-align: center;
    }
    #userAvatar { width: 64px; height: 64px; border-radius: 50%; }
    #userName { font-weight: bold; }
    .menu-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.5);
        z-index: 250;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }
    .menu-overlay.hidden { opacity: 0; visibility: hidden; display: none; }
    footer { text-align: center; padding: 20px 15px; border-top: 1px solid #2a2a2a; margin-top: 20px; }
    footer a { color: var(--muted); text-decoration: none; margin: 0 10px; font-size: 0.9rem; }
    footer a:hover { color: var(--text); }
    
    /* Menu Links */
    .menu-links { margin-top: 30px; border-top: 1px solid #2a2a2a; padding-top: 20px; }
    .menu-link { 
      display: block; padding: 12px; margin: 5px 0; text-decoration: none; color: var(--text);
      border-radius: 8px; transition: all 0.2s ease; font-size: 0.95rem;
      background: rgba(37,37,37,0.5);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.05);
    }
    .menu-link:hover { background: rgba(255,255,255,0.1); transform: translateX(-3px); }
    
    /* API Quota Counter */
    .quota-container {
      margin-top: 30px;
      padding: 16px;
      background: rgba(15,15,15,0.5);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
    }
    .quota-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .quota-label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text);
    }
    .quota-value {
      font-size: 1rem;
      color: var(--text);
      font-weight: 600;
      font-family: monospace;
    }
    .quota-bar {
      height: 12px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      margin-bottom: 8px;
    }
    .quota-progress {
      height: 100%;
      background: linear-gradient(90deg, #10b981, #10b981);
      border-radius: 8px;
      width: 0%;
      transition: width 0.5s ease, background 0.3s ease;
    }
    .quota-progress.warning {
      background: linear-gradient(90deg, #f59e0b, #f59e0b);
    }
    .quota-progress.danger {
      background: linear-gradient(90deg, #ef4444, #ef4444);
    }
    .quota-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: var(--muted);
    }
    #quotaPercent {
      font-weight: 600;
      font-family: monospace;
    }
    .quota-reset {
      font-size: 0.75rem;
      opacity: 0.7;
    }
    
    /* Light Mode */
    body.text-light .quota-container {
      background: rgba(255,255,255,0.5);
      border-color: rgba(0,0,0,0.1);
    }
    body.text-light .quota-bar {
      background: rgba(0,0,0,0.1);
    }
    
    /* Settings Page */
    .settings-section { margin-top: 20px; }
    .settings-section h3 { font-size: 1.1rem; margin: 20px 4px 15px; border-bottom: 1px solid #2a2a2a; padding-bottom: 8px; }
    .setting-group { 
      background: rgba(15,15,15,0.5); 
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1); 
      border-radius: var(--radius);
      padding: 20px; margin-bottom: 15px;
    }
    .setting-label { display: block; font-weight: 600; margin-bottom: 12px; font-size: 0.95rem; }
    .setting-hint { display: block; margin-top: 8px; font-size: 0.85rem; color: var(--muted); font-style: italic; }
    
    .toggle-buttons { display: flex; gap: 8px; flex-wrap: wrap; }
    .toggle-btn { 
      padding: 8px 16px; border-radius: 8px; 
      border: 1px solid rgba(255,255,255,0.1); 
      background: rgba(15,15,15,0.5);
      backdrop-filter: blur(12px);
      color: var(--text); cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem;
    }
    .toggle-btn:hover { background: rgba(37,37,37,0.85); transform: translateY(-2px); }
    .toggle-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }
    
    .color-palette { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; }
    .color-option { 
      width: 100%; aspect-ratio: 1; border-radius: 12px; border: 3px solid transparent;
      cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .color-option:hover { transform: scale(1.1); }
    .color-option.active { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(255,0,51,0.2); }
    
    /* Channel Management */
    .channel-add-section .channel-add-input-wrapper {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .channel-add-section input {
      flex: 1;
      min-width: 200px;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: var(--text);
      font-size: 0.9rem;
    }
    .channel-add-section button {
      flex-shrink: 0;
      white-space: nowrap;
    }
    @media (max-width: 600px) {
      .channel-add-section .channel-add-input-wrapper {
        flex-direction: column;
      }
      .channel-add-section input {
        width: 100%;
        min-width: unset;
      }
      .channel-add-section button {
        width: 100%;
      }
    }
    
    .channel-management-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      max-height: 400px;
      overflow-y: auto;
    }
    @media (max-width: 768px) {
      .channel-management-list {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
    }
    @media (max-width: 600px) {
      .channel-management-list {
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
    }
    @media (max-width: 400px) {
      .channel-management-list {
        grid-template-columns: 1fr;
      }
    }
    .channel-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 16px 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      transition: all 0.2s ease;
    }
    .channel-item:hover {
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.15);
      transform: translateY(-2px);
    }
    .channel-item-thumb {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
    }
    .channel-item-info {
      text-align: center;
      width: 100%;
      min-width: 0;
    }
    .channel-item-name {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
    }
    .channel-item-handle {
      font-size: 0.75rem;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .channel-item-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      width: 100%;
      flex-shrink: 0;
    }
        .favorite-checkbox {
            width: 36px;
            height: 36px;
            cursor: pointer;
            position: relative;
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                color: rgba(0, 0, 0, 0.45);
        }
        .favorite-checkbox svg {
            width: 18px;
            height: 18px;
            pointer-events: none;
                fill: currentColor;
                transition: color 0.3s ease, transform 0.3s ease;
        }
        .favorite-checkbox:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.25);
            backdrop-filter: blur(12px);
            transform: scale(1.05);
                color: rgba(0, 0, 0, 0.7);
        }
        .favorite-checkbox.active {
            background: rgba(251, 191, 36, 0.18);
            border-color: rgba(251, 191, 36, 0.45);
            backdrop-filter: blur(12px);
                color: #fbbf24;
        }
        .favorite-checkbox.active:hover {
            background: rgba(251, 191, 36, 0.22);
            border-color: #facc15;
            transform: scale(1.05);
                color: #facc15;
        }
    .remove-channel-btn {
      width: 36px;
      height: 36px;
      font-size: 16px;
      background: rgba(239, 68, 68, 0.1);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(239, 68, 68, 0.2);
      color: #ef4444;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
    }
        .remove-channel-btn svg {
            width: 18px;
            height: 18px;
            pointer-events: none;
            stroke: currentColor;
            stroke-width: 1.6;
            fill: none;
        }
    .remove-channel-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: rgba(239, 68, 68, 0.4);
      backdrop-filter: blur(12px);
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
    }
    
    /* Light Mode */
    body.text-light .channel-item {
      background: rgba(0,0,0,0.03);
      border-color: rgba(0,0,0,0.08);
    }
    body.text-light .channel-item:hover {
      background: rgba(0,0,0,0.06);
      border-color: rgba(0,0,0,0.15);
    }
    body.text-light .channel-item-thumb {
      border-color: rgba(0,0,0,0.1);
    }
    body.text-light .favorite-checkbox {
      background: rgba(0,0,0,0.05);
      border-color: rgba(0,0,0,0.15);
            color: rgba(0,0,0,0.55);
    }
    body.text-light .favorite-checkbox:hover {
      background: rgba(0,0,0,0.08);
      border-color: rgba(0,0,0,0.25);
            color: rgba(0,0,0,0.75);
    }
    body.text-light .favorite-checkbox.active {
      background: rgba(251, 191, 36, 0.2);
      border-color: rgba(251, 191, 36, 0.5);
            color: #f59e0b;
    }
        body.text-light .favorite-checkbox.active:hover {
            color: #fbbf24;
        }
    body.text-light .remove-channel-btn {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.25);
    }
    body.text-light .remove-channel-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: rgba(239, 68, 68, 0.4);
    }
    body.text-light #addChannelInput {
      background: rgba(0,0,0,0.05) !important;
      border-color: rgba(0,0,0,0.1) !important;
    }
    
    .bg-upload-container { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .bg-preview { 
      margin-top: 15px; width: 100%; max-width: 300px; aspect-ratio: 16/9; 
      border-radius: var(--radius); background-size: cover; background-position: center;
      border: 2px solid #2a2a2a; box-shadow: var(--shadow);
    }
    .bg-preview.hidden { display: none; }
    
    /* Background Image Overlay */
    body.has-bg-image::before {
      content: ''; position: fixed; inset: 0; z-index: -1;
      background-size: cover; background-position: center top; background-attachment: fixed;
      background-image: var(--bg-image, none);
      pointer-events: none;
    }
    
    /* Gradient Fade von oben nach unten */
    body.has-bg-image::after {
      content: ''; position: fixed; inset: 0; z-index: -1;
      background: linear-gradient(to bottom, 
        rgba(0,0,0,0) 0%, 
        rgba(0,0,0,0.3) 50%,
        var(--bg) 100%
      );
      pointer-events: none;
    }
    
    /* Light Mode Gradient */
    body.text-light.has-bg-image::after {
      background: linear-gradient(to bottom, 
        rgba(255,255,255,0) 0%, 
        rgba(255,255,255,0.3) 50%,
        var(--bg) 100%
      );
    }
    .text-page { line-height: 1.8; transition: all 0.3s ease; }
    .text-page h2, .text-page h3 { border-bottom: 1px solid #2a2a2a; padding-bottom: 10px; transition: color 0.3s ease; }
    .text-page p, .text-page ul { color: var(--muted); transition: color 0.3s ease; }
    .text-page a { color: var(--accent); text-decoration: none; transition: all 0.2s ease; }
    .text-page a:hover { text-decoration: underline; opacity: 0.8; }
    .text-content {
        background: rgba(15,15,15,0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 12px;
        padding: 24px 28px;
        margin: 12px 0;
    }
    .text-content h2:first-child {
        margin-top: 0;
    }
    .page-header {
        background: rgba(15,15,15,0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 14px 20px;
        margin: 0 0 16px 0;
    }
    .page-header h2 {
        margin: 0;
        font-size: 1.4rem;
        font-weight: 600;
    }
    
    /* Loading Skeleton Styles */
    .skeleton { background: linear-gradient(90deg, #1a1a1a 25%, #252525 50%, #1a1a1a 75%); background-size: 200% 100%; animation: loading 1.5s ease-in-out infinite; border-radius: 8px; }
    @keyframes loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    .skeleton-card { background: var(--card); border: 1px solid #262626; border-radius: var(--radius); overflow: hidden; box-shadow: var(--shadow); }
    .skeleton-channel { padding: 12px; display: flex; flex-direction: column; gap: 8px; align-items: center; }
    .skeleton-channel .skeleton-thumb { width: 48px; height: 48px; border-radius: 50%; }
    .skeleton-channel .skeleton-text { width: 80%; height: 16px; }
    .skeleton-video { display: flex; flex-direction: column; }
    .skeleton-video .skeleton-thumb-rect { width: 100%; aspect-ratio: 16/9; }
    .skeleton-video .skeleton-body { padding: 10px 12px; display: flex; flex-direction: column; gap: 8px; }
    .skeleton-video .skeleton-title { width: 100%; height: 16px; }
    .skeleton-video .skeleton-meta { width: 60%; height: 12px; }
    
    /* Notification System with Glassmorphism */
    #statusBox {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        max-width: 500px;
        width: 90%;
        padding: 16px 24px;
        background: rgba(15,15,15,0.85);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        color: var(--text);
        font-size: 0.95rem;
        z-index: 10000;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideDown 0.3s ease;
        transition: all 0.3s ease;
    }
    
    #statusBox::before {
        content: '';
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
    }
    
    /* Loading State */
    #statusBox.loading::before {
        content: '⏳';
        font-size: 20px;
        animation: pulse 1.5s ease-in-out infinite;
    }
    
    /* Success State */
    #statusBox.success {
        background: rgba(16,185,129,0.2);
        border-color: rgba(16,185,129,0.4);
    }
    #statusBox.success::before {
        content: '✓';
        font-size: 20px;
        color: #10b981;
        font-weight: bold;
    }
    
    /* Error State */
    #statusBox.error {
        background: rgba(239,68,68,0.2);
        border-color: rgba(239,68,68,0.4);
    }
    #statusBox.error::before {
        content: '✕';
        font-size: 20px;
        color: #ef4444;
        font-weight: bold;
    }
    
    /* Info State */
    #statusBox.info {
        background: rgba(59,130,246,0.2);
        border-color: rgba(59,130,246,0.4);
    }
    #statusBox.info::before {
        content: 'ℹ';
        font-size: 20px;
        color: #3b82f6;
        font-weight: bold;
    }
    
    /* Light Mode */
    body.text-light #statusBox {
        background: rgba(255,255,255,0.85);
        border-color: rgba(0,0,0,0.15);
        box-shadow: 0 8px 32px rgba(0,0,0,0.15);
    }
    body.text-light #statusBox.success {
        background: rgba(16,185,129,0.15);
        border-color: rgba(16,185,129,0.3);
    }
    body.text-light #statusBox.error {
        background: rgba(239,68,68,0.15);
        border-color: rgba(239,68,68,0.3);
    }
    body.text-light #statusBox.info {
        background: rgba(59,130,246,0.15);
        border-color: rgba(59,130,246,0.3);
    }
    
    /* Hidden State */
    #statusBox.hidden {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
        pointer-events: none;
    }
    
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }
    
    @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.1); opacity: 0.7; }
    }
  </style>
</head>
<body>

<header>
  <div class="topbar">
    <div class="topbar-left">
      <button class="btn" id="backBtn">←</button>
      <button class="btn" id="homeBtn">Home</button>
      <button class="btn" id="refreshBtn"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg></button>
      <button class="btn" id="forwardBtn">→</button>
    </div>
    <div class="topbar-right">
      <button class="btn" id="themeToggleBtn" title="Theme wechseln"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/></svg></button>
      <button class="btn menu-btn" id="menuBtn">☰</button>
    </div>
  </div>
</header>

<div class="side-menu" id="sideMenu">
  <div class="auth-container">
    <img id="userAvatar" class="hidden" alt="User Avatar">
    <span id="userName"></span>
    <button class="btn" id="authBtn">Anmelden</button>
  </div>
  <div class="menu-links">
    <a href="#" class="menu-link" id="continueWatchingLink">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-right: 8px;">
        <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/>
      </svg>
      Angefangene Videos
    </a>
    <a href="#" class="menu-link" id="myListLink">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-right: 8px;">
        <path d="M2.5 8a5.5 5.5 0 0 1 8.25-4.764.5.5 0 0 0 .5-.866A6.5 6.5 0 1 0 14.5 8a.5.5 0 0 0-1 0 5.5 5.5 0 1 1-11 0z"/>
        <path d="M15.354 3.354a.5.5 0 0 0-.708-.708L8 9.293 5.354 6.646a.5.5 0 1 0-.708.708l3 3a.5.5 0 0 0 .708 0l7-7z"/>
      </svg>
      Meine Liste
    </a>
    <a href="#settings" class="menu-link">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-right: 8px;">
        <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/>
        <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52l-.094-.319z"/>
      </svg>
      Einstellungen
    </a>
  </div>
  
  <div class="quota-container">
    <div class="quota-header">
      <span class="quota-label">API Kontingent</span>
      <span class="quota-value" id="quotaPercent">0%</span>
    </div>
    <div class="quota-bar">
      <div class="quota-progress" id="quotaProgress"></div>
    </div>
    <div class="quota-info">
      <span class="quota-reset">Reset: 09:00 Uhr</span>
    </div>
  </div>
</div>
<div class="menu-overlay hidden" id="menuOverlay"></div>

<main>
  <div id="statusBox" class="hidden"></div>
  <section id="homeView" class="section">
    <h2>Deine Lieblingskanäle</h2>
    <div class="grid cols-channels" id="favoriteChannelGrid"></div>
    <details>
      <summary>Weitere Kanäle anzeigen</summary>
      <div class="details-content">
        <div class="grid cols-channels" id="otherChannelGrid"></div>
      </div>
    </details>
    <div class="section">
      <h2>Neueste Videos</h2>
      <div class="grid cols-vids" id="latestVideosGrid"></div>
    </div>
  </section>
  <section id="channelView" class="section hidden">
    <h2 id="channelName" style="margin: 0 4px 12px 4px;"></h2>
    <div id="channelBannerContainer" class="hidden">
        <div id="channelBannerBackground"></div>
    </div>
    <div class="searchbar">
      <input id="searchInput" placeholder="Im Kanal suchen…"/>
      <button class="btn hidden" id="clearSearchBtn" title="Suche zurücksetzen">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
        </svg>
      </button>
      <button class="btn" id="searchBtn">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
        </svg>
      </button>
      <div class="sort-options hidden" id="sortOptions">
        <span class="sub">Sortieren:</span>
        <button class="btn active" data-sort="date">Neueste</button>
        <button class="btn" data-sort="relevance">Relevanz</button>
        <button class="btn" data-sort="viewCount">Beliebt</button>
      </div>
    </div>
    <div class="tabs">
      <button class="tab" data-tab="videos">Videos</button>
      <button class="tab" data-tab="playlists">Playlists</button>
    </div>
    <div id="videosTab" class="grid cols-vids"></div>
    <button id="moreVideosBtn" class="loadmore hidden">Mehr Videos laden</button>
    <div id="playlistsTab" class="grid cols-vids hidden"></div>
    <button id="morePlaylistsBtn" class="loadmore hidden">Mehr Playlists laden</button>
  </section>
  <section id="privacyView" class="section text-page hidden">
    <h2>Datenschutzerklärung</h2>
    <div class="text-content">
      <h3>1. Allgemeines</h3>
      <p>Diese Datenschutzerklärung erläutert, wie YouTube Whitelist deine persönlichen Daten erhebt, nutzt und schützt.</p>
      
      <h3>2. Daten die wir erheben</h3>
      <ul>
        <li><strong>Google-Kontodaten:</strong> Name, E-Mail, Profilfoto (über Firebase Authentication)</li>
        <li><strong>Video-Fortschritt:</strong> Welche Videos du schaust, wie weit du fortgeschritten bist</li>
        <li><strong>Einstellungen:</strong> Deine Farbpräferenzen, Hintergrundbilder, Text-Modus-Einstellungen</li>
        <li><strong>Favoriten:</strong> Deine ausgewählten Kanäle und deren Einstellungen</li>
      </ul>
      
      <h3>3. Speicherung der Daten</h3>
      <p>Deine Daten werden in Google Firebase gespeichert und mit deinem Google-Konto synchronisiert. Hintergrundbild-Dateien werden als Base64 in Firebase gespeichert.</p>
      
      <h3>4. Externe APIs</h3>
      <p>Wir nutzen die YouTube Data API v3 zur Abfrage von Kanal- und Video-Informationen. Dies geschieht nur auf deinen Wunsch hin (via Klick auf den Aktualisierungs-Button).</p>
      
      <h3>5. Deine Rechte</h3>
      <p>Du kannst jederzeit alle deine Daten einsehen, ändern oder löschen, indem du dein Google-Konto verwaltest oder diese App verlässt.</p>
    </div>
  </section>
  <section id="termsView" class="section text-page hidden">
    <h2>Nutzungsbedingungen</h2>
    <div class="text-content">
      <h3>1. Akzeptanz der Bedingungen</h3>
      <p>Mit der Nutzung dieser App akzeptierst du diese Nutzungsbedingungen.</p>
      
      <h3>2. YouTube API Nutzung</h3>
      <p>Diese App nutzt die YouTube Data API gemäß den <a href="https://www.youtube.com/static?template=terms" target="_blank">YouTube-Bedingungen</a>. Du stimmst zu, die API nur entsprechend dieser Bedingungen zu nutzen.</p>
      
      <h3>3. Keine Gewährleistung</h3>
      <p>Diese App wird "wie vorhanden" bereitgestellt. Wir garantieren nicht, dass sie fehlerfrei oder kontinuierlich verfügbar ist.</p>
      
      <h3>4. Haftungsbeschränkung</h3>
      <p>Wir haften nicht für Datenverlust, Systemausfälle oder andere Schäden, die sich aus der Nutzung dieser App ergeben.</p>
      
      <h3>5. Änderungen</h3>
      <p>Diese Bedingungen können jederzeit geändert werden. Du wirst über wichtige Änderungen informiert.</p>
    </div>
  </section>
  <section id="settingsView" class="section hidden">
    <h2>Einstellungen</h2>
    
    <div class="settings-section">
      <div class="setting-group">
        <label class="setting-label">Minimale Videolänge</label>
        <div class="duration-controls">
            <button class="btn duration-btn" id="durationMinusBtn">-</button>
            <span id="durationValue" class="duration-display">2 min</span>
            <button class="btn duration-btn" id="durationPlusBtn">+</button>
        </div>
        <p class="setting-hint">Filtert Videos unter der eingestellten Dauer aus. "Alle" zeigt alle Videos an.</p>
      </div>

      <div class="setting-group">
        <label class="setting-label">Hintergrundbild</label>
        <div class="bg-upload-container">
          <input type="file" id="bgImageInput" accept="image/*" style="display: none;">
          <button class="btn" id="bgImageBtn">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 6px;">
              <path d="M.002 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-12a2 2 0 0 1-2-2V3zm1 9v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V9.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12zm5-6.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0z"/>
            </svg>
            Bild hochladen
          </button>
          <button class="btn" id="bgImageRemoveBtn">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 6px;">
              <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
              <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
            </svg>
            Entfernen
          </button>
        </div>
        <div id="bgPreview" class="bg-preview hidden"></div>
        <p class="setting-hint">Das Hintergrundbild wird in deinem Browser gespeichert und mit deinem Google-Konto synchronisiert.</p>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">Kanal-Verwaltung</label>
        
        <div class="channel-add-section">
          <p style="color: var(--muted); font-size: 0.9rem; margin-bottom: 12px;">Neuen Kanal hinzufügen (YouTube-URL eingeben):</p>
          <div class="channel-add-input-wrapper">
            <input 
              type="text" 
              id="addChannelInput" 
              placeholder="https://www.youtube.com/@Kanalname"
            />
            <button class="btn" id="addChannelBtn">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 6px;">
                <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
              </svg>
              Hinzufügen
            </button>
          </div>
        </div>
        
        <p style="color: var(--muted); font-size: 0.9rem; margin-bottom: 12px;">Deine Kanäle:</p>
        <div id="channelManagementList" class="channel-management-list"></div>
        <p class="setting-hint">Favoriten erscheinen ganz oben auf der Startseite. Du kannst Kanäle auch komplett entfernen.</p>
      </div>
    </div>
  </section>
  <section id="continueView" class="section text-page hidden">
    <div class="page-header">
      <h2>Angefangene Videos</h2>
    </div>
    <div class="grid cols-vids" id="continueViewGrid"></div>
  </section>
  <section id="mylistView" class="section text-page hidden">
    <div class="page-header">
      <h2>Meine Liste</h2>
    </div>
    <div class="grid cols-vids" id="mylistViewGrid"></div>
  </section>
</main>

<footer>
  <a href="#terms">Nutzungsbedingungen</a>
  <a href="#privacy">Datenschutzerklärung</a>
</footer>

<div class="overlay" id="playerOverlay" role="dialog">
    <div class="modal">
        <div class="modal-header">
          <strong id="playerTitle">Video</strong>
          <button class="btn" id="playerClose">Schließen</button>
        </div>
        <div class="modal-body">
          <div id="player-mount" class="modal-iframe-container"></div>
        </div>
    </div>
</div>

<div class="overlay" id="myListOverlay" role="dialog">
    <div class="modal">
        <div class="modal-header">
          <strong>Meine Liste</strong>
          <button class="btn" id="myListClose">Schließen</button>
        </div>
        <div class="modal-body" style="padding: 1rem;">
          <div id="myListVideos" class="grid cols-vids"></div>
        </div>
    </div>
</div>

<div class="overlay" id="continueWatchingOverlay" role="dialog">
    <div class="modal">
        <div class="modal-header">
          <strong>Angefangene Videos</strong>
          <button class="btn" id="continueWatchingClose">Schließen</button>
        </div>
        <div class="modal-body" style="padding: 1rem;">
          <div id="continueWatchingVideos" class="grid cols-vids"></div>
        </div>
    </div>
</div>

<div class="overlay" id="playlistOverlay" role="dialog">
    <div class="modal">
        <div class="modal-header">
          <strong id="playlistTitle">Playlist</strong>
          <button class="btn" id="playlistClose">Schließen</button>
        </div>
        <div class="modal-body" style="padding: 1rem;">
          <div id="playlistVideos" class="grid cols-vids"></div>
          <button id="morePlaylistVideosBtn" class="loadmore hidden">Mehr Videos laden</button>
        </div>
    </div>
</div>

<script>
// ===== YOUTUBE IFRAME API =====
var tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
var firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
function onYouTubeIframeAPIReady() { window.dispatchEvent(new Event('youtube-api-ready')); }

document.addEventListener('DOMContentLoaded', () => {
    // ===== CONFIG =====
    const YOUTUBE_API_KEY = "AIzaSyDdATTj976Ga3IRTFIqWbSYxORlp3mXT9w"; 
    const firebaseConfig = {
      apiKey: "AIzaSyCWI6Z0Z9NXmbYkoK9ersdKj2dbI0tSHa4",
      authDomain: "whitelist-v3.firebaseapp.com",
      projectId: "whitelist-v3",
      storageBucket: "whitelist-v3.appspot.com",
      messagingSenderId: "747410045455",
      appId: "1:747410045455:web:805ede68f0aefffae1417a"
    };
    
    const CHANNELS_CONFIG = [
        { handle: '@jpperformance', isFavorite: true }, { handle: '@Autodoktoren', isFavorite: true },
        { handle: '@Simplicissimus', isFavorite: true }, { handle: '@EngineeringExplained', isFavorite: true },
        { handle: '@BreakingLab', isFavorite: false }, { handle: '@veritasium', isFavorite: false },
        { handle: '@2boredguys', isFavorite: false }, { handle: '@automotorsport', isFavorite: false },
        { handle: '@MrWissen2go', isFavorite: false }, { handle: '@TerraXLeschundCo', isFavorite: false },
        { handle: '@terraxhistory', isFavorite: false }
    ];

    // ===== STATE & ELEMENTS =====
    const state = {
        user: null, userId: null,
        progressData: new Map(),
        progressListenerUnsubscribe: null,
        channels: new Map(), 
        videoDetailsCache: new Map(),
        myList: new Map(), // Video-ID -> Video-Object für "Meine Liste"
        current: { 
            channelId: null, tab: 'videos', videosPageToken: null, 
            playlistsPageToken: null, player: null, playerStateInterval: null, searchQuery: null, searchOrder: 'date'
        },
        lastChannelRoute: null,
        theme: 'dark', // 'dark' oder 'light'
        bgImage: null, // Base64 oder URL des Hintergrundbildes
        settings: {
            minDuration: 120 // in seconds (0 = Alle)
        },
        quota: {
            used: 0,
            limit: 10000,
            resetTime: null
        },
        channelsConfig: [] // Dynamische Kanal-Liste
    };
    const els = {
        statusBox: document.getElementById('statusBox'), 
        homeView: document.getElementById('homeView'), 
        channelView: document.getElementById('channelView'),
        privacyView: document.getElementById('privacyView'),
        termsView: document.getElementById('termsView'),
        favoriteChannelGrid: document.getElementById('favoriteChannelGrid'),
        otherChannelGrid: document.getElementById('otherChannelGrid'), 
        latestVideosGrid: document.getElementById('latestVideosGrid'),
        tabs: document.querySelectorAll('.tab'), videosTab: document.getElementById('videosTab'), playlistsTab: document.getElementById('playlistsTab'),
        moreVideosBtn: document.getElementById('moreVideosBtn'), morePlaylistsBtn: document.getElementById('morePlaylistsBtn'),
        searchInput: document.getElementById('searchInput'), searchBtn: document.getElementById('searchBtn'),
        clearSearchBtn: document.getElementById('clearSearchBtn'),
        sortOptions: document.getElementById('sortOptions'),
        channelBannerContainer: document.getElementById('channelBannerContainer'), channelBannerBackground: document.getElementById('channelBannerBackground'),
        channelName: document.getElementById('channelName'),
        overlay: document.getElementById('playerOverlay'), 
        playerClose: document.getElementById('playerClose'),
        playerMount: document.getElementById('player-mount'), 
        playerTitle: document.getElementById('playerTitle'),
        playlistOverlay: document.getElementById('playlistOverlay'),
        playlistClose: document.getElementById('playlistClose'),
        playlistTitle: document.getElementById('playlistTitle'), 
        playlistVideos: document.getElementById('playlistVideos'),
        morePlaylistVideosBtn: document.getElementById('morePlaylistVideosBtn'), 
        myListOverlay: document.getElementById('myListOverlay'),
        myListClose: document.getElementById('myListClose'),
        myListVideos: document.getElementById('myListVideos'),
        continueWatchingOverlay: document.getElementById('continueWatchingOverlay'),
        continueWatchingClose: document.getElementById('continueWatchingClose'),
        continueWatchingVideos: document.getElementById('continueWatchingVideos'),
        continueWatchingLink: document.getElementById('continueWatchingLink'),
        myListLink: document.getElementById('myListLink'),
        homeBtn: document.getElementById('homeBtn'), 
        refreshBtn: document.getElementById('refreshBtn'), 
        backBtn: document.getElementById('backBtn'),
        forwardBtn: document.getElementById('forwardBtn'),
        backToChannelBtn: document.getElementById('backToChannelBtn'),
        authBtn: document.getElementById('authBtn'),
        userAvatar: document.getElementById('userAvatar'),
        userName: document.getElementById('userName'),
        menuBtn: document.getElementById('menuBtn'),
        sideMenu: document.getElementById('sideMenu'),
        menuOverlay: document.getElementById('menuOverlay'),
        settingsView: document.getElementById('settingsView'),
        continueView: document.getElementById('continueView'),
        mylistView: document.getElementById('mylistView'),
        continueViewGrid: document.getElementById('continueViewGrid'),
        mylistViewGrid: document.getElementById('mylistViewGrid'),
        themeToggleBtn: document.getElementById('themeToggleBtn'),
        durationValue: document.getElementById('durationValue'),
        durationMinusBtn: document.getElementById('durationMinusBtn'),
        quotaProgress: document.getElementById('quotaProgress'),
        quotaPercent: document.getElementById('quotaPercent'),
        durationPlusBtn: document.getElementById('durationPlusBtn'),
        bgImageInput: document.getElementById('bgImageInput'),
        bgImageBtn: document.getElementById('bgImageBtn'),
        bgImageRemoveBtn: document.getElementById('bgImageRemoveBtn'),
        bgPreview: document.getElementById('bgPreview'),
        addChannelInput: document.getElementById('addChannelInput'),
        addChannelBtn: document.getElementById('addChannelBtn'),
        channelManagementList: document.getElementById('channelManagementList'),
    };
    
    // ===== FIREBASE SETUP =====
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    const homeCacheRef = db.collection('cache').doc('homeData');
    const videoDetailsCacheRef = db.collection('cache').doc('videoDetails');
    const channelInfoCacheRef = db.collection('cache').doc('channelInfo');

    // ===== SETTINGS =====
    const saveSettings = () => {
        try {
            localStorage.setItem('settings', JSON.stringify(state.settings));
        } catch (e) {
            console.error('Failed to save settings', e);
        }
    };

    const loadSettings = () => {
        try {
            const saved = localStorage.getItem('settings');
            if (saved) {
                const parsed = JSON.parse(saved);
                state.settings = { ...state.settings, ...parsed };
            }
        } catch (e) {
            console.error('Failed to load settings', e);
        }
    };
    
    const applySettings = () => {
        const value = state.settings.minDuration;
        const minutes = Math.floor(value / 60);
        const seconds = value % 60;
        if (minutes > 0) {
            els.durationValue.textContent = `${minutes} min` + (seconds > 0 ? ` ${seconds}s` : '');
        } else if (value > 0) {
            els.durationValue.textContent = `${seconds}s`;
        } else {
            els.durationValue.textContent = 'Alle';
        }
    };

    // ===== API QUOTA MANAGEMENT =====
    const QUOTA_COSTS = {
        search: 100,
        videos: 1,
        channels: 1,
        playlistItems: 1,
        playlists: 1
    };
    
    const loadQuotaState = () => {
        try {
            const saved = localStorage.getItem('apiQuota');
            if (saved) {
                const data = JSON.parse(saved);
                state.quota = data;
                
                // Prüfe ob Reset-Zeit überschritten
                if (data.resetTime && new Date() >= new Date(data.resetTime)) {
                    resetQuota();
                }
            } else {
                resetQuota();
            }
        } catch (e) {
            console.error('Quota laden fehlgeschlagen:', e);
            resetQuota();
        }
        updateQuotaUI();
    };
    
    const saveQuotaState = () => {
        try {
            localStorage.setItem('apiQuota', JSON.stringify(state.quota));
        } catch (e) {
            console.error('Quota speichern fehlgeschlagen:', e);
        }
    };
    
    const resetQuota = () => {
        const now = new Date();
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(9, 0, 0, 0); // 09:00 Uhr deutscher Zeit
        
        state.quota = {
            used: 0,
            limit: 10000,
            resetTime: tomorrow.toISOString()
        };
        saveQuotaState();
        updateQuotaUI();
        console.log('📊 API Quota zurückgesetzt. Nächster Reset:', tomorrow.toLocaleString('de-DE'));
    };
    
    const addQuotaCost = (endpoint, count = 1) => {
        const cost = (QUOTA_COSTS[endpoint] || 1) * count;
        state.quota.used += cost;
        saveQuotaState();
        updateQuotaUI();
        console.log(`📊 API Quota: +${cost} (${endpoint}) → ${state.quota.used} / ${state.quota.limit}`);
    };
    
    const updateQuotaUI = () => {
        const { used, limit } = state.quota;
        const percent = Math.min(100, Math.round((used / limit) * 100));
        
        els.quotaPercent.textContent = `${percent}%`;
        els.quotaProgress.style.width = `${percent}%`;
        
        // Farbe basierend auf Prozent
        els.quotaProgress.classList.remove('warning', 'danger');
        if (percent >= 90) {
            els.quotaProgress.classList.add('danger');
        } else if (percent >= 75) {
            els.quotaProgress.classList.add('warning');
        }
    };
    
    // Check Quota Reset jeden Minute
    setInterval(() => {
        if (state.quota.resetTime && new Date() >= new Date(state.quota.resetTime)) {
            resetQuota();
            showNotification('API Kontingent wurde zurückgesetzt 🔄', 'success');
        }
    }, 60000); // Jede Minute

    // ===== CHANNEL MANAGEMENT =====
    const loadChannelConfig = () => {
        try {
            const saved = localStorage.getItem('channelConfig');
            if (saved) {
                return JSON.parse(saved);
            }
        } catch (e) {
            console.error('Fehler beim Laden der Kanal-Konfiguration:', e);
        }
        // Fallback auf CHANNELS_CONFIG
        return CHANNELS_CONFIG.slice();
    };
    
    const saveChannelConfig = (config) => {
        try {
            localStorage.setItem('channelConfig', JSON.stringify(config));
            state.channelsConfig = config;
        } catch (e) {
            console.error('Fehler beim Speichern der Kanal-Konfiguration:', e);
        }
    };
    
    const renderChannelList = async () => {
        if (!els.channelManagementList) return;
        
        els.channelManagementList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);">Lädt Kanäle...</div>';
        
        const config = loadChannelConfig();
        if (config.length === 0) {
            els.channelManagementList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);">Keine Kanäle vorhanden</div>';
            return;
        }
        
        els.channelManagementList.innerHTML = '';
        
        for (const channelConfig of config) {
            const info = await getChannelInfo(channelConfig.handle);
            if (!info) continue;
            
            const item = document.createElement('div');
            item.className = 'channel-item';
            item.dataset.handle = channelConfig.handle;
            item.dataset.channelId = info.id;
            
            item.innerHTML = `
                <img class="channel-item-thumb" src="${info.thumb}" alt="">
                <div class="channel-item-info">
                    <div class="channel-item-name">${info.title}</div>
                    <div class="channel-item-handle">${channelConfig.handle}</div>
                </div>
                <div class="channel-item-actions">
                    <button class="favorite-checkbox ${channelConfig.isFavorite ? 'active' : ''}" data-handle="${channelConfig.handle}" title="Als Favorit markieren">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="m12 2 2.317 4.695 5.183.754-3.75 3.656.885 5.166L12 13.77l-4.635 2.501.885-5.166-3.75-3.656 5.183-.754L12 2z"/>
                        </svg>
                    </button>
                    <button class="remove-channel-btn" data-handle="${channelConfig.handle}" title="Kanal entfernen">
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M6 7h12" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M10 7V5a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8 7v11a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V7" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            `;
            
            els.channelManagementList.appendChild(item);
        }
        
        // Event-Listener für Favorite-Toggle
        els.channelManagementList.querySelectorAll('.favorite-checkbox').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFavorite(btn.dataset.handle);
            });
        });
        
        // Event-Listener für Remove
        els.channelManagementList.querySelectorAll('.remove-channel-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeChannel(btn.dataset.handle);
            });
        });
    };
    
    const toggleFavorite = async (handle) => {
        const config = loadChannelConfig();
        const channel = config.find(c => c.handle === handle);
        
        if (channel) {
            channel.isFavorite = !channel.isFavorite;
            saveChannelConfig(config);
            renderChannelList();
            
            // Aktualisiere auch den Firebase Cache
            try {
                const cacheDoc = await homeCacheRef.get();
                if (cacheDoc.exists) {
                    const data = cacheDoc.data();
                    if (data.channels) {
                        // Finde den Kanal im Cache
                        const cachedChannel = data.channels.find(ch => 
                            ch.handle === handle || ch.title.toLowerCase().includes(handle.toLowerCase().replace('@', ''))
                        );
                        if (cachedChannel) {
                            cachedChannel.isFavorite = channel.isFavorite;
                            await homeCacheRef.update({ channels: data.channels });
                        }
                    }
                }
            } catch (e) {
                console.error('Fehler beim Aktualisieren des Cache:', e);
            }
            
            showNotification(channel.isFavorite ? 'Als Favorit markiert ⭐' : 'Favorit entfernt ☆', 'success');
        }
    };
    
    const removeChannel = async (handle) => {
        const config = loadChannelConfig();
        
        if (config.length <= 1) {
            showNotification('Mindestens ein Kanal muss vorhanden bleiben', 'error');
            return;
        }
        
        const index = config.findIndex(c => c.handle === handle);
        if (index === -1) return;
        
        const channelName = config[index].handle;
        config.splice(index, 1);
        saveChannelConfig(config);
        
        await renderChannelList();
        showNotification(`Kanal ${channelName} entfernt 🗑️`, 'success');
    };
    
    const addNewChannel = async () => {
        const input = els.addChannelInput.value.trim();
        console.log('🔍 DEBUG: Input-Wert:', input);
        
        if (!input) {
            showNotification('Bitte gib einen Kanalnamen ein', 'info');
            return;
        }
        
        // Parse URL falls vorhanden
        let identifier = input;
        
        // Prüfe ob es eine YouTube URL ist
        if (input.includes('youtube.com/') || input.includes('youtu.be/')) {
            try {
                const url = new URL(input.startsWith('http') ? input : 'https://' + input);
                
                // Extrahiere @handle aus URL wie youtube.com/@DoktorWhatson
                if (url.pathname.startsWith('/@')) {
                    identifier = url.pathname.split('/')[1]; // z.B. /@DoktorWhatson
                    console.log('🔗 Handle aus URL extrahiert:', identifier);
                }
                // Extrahiere Channel-ID aus URL wie youtube.com/channel/UCxxxxx
                else if (url.pathname.startsWith('/channel/')) {
                    identifier = url.pathname.split('/')[2]; // Channel-ID
                    console.log('🔗 Channel-ID aus URL extrahiert:', identifier);
                }
            } catch (e) {
                console.warn('URL-Parsing fehlgeschlagen:', e);
            }
        }
        
        // Stelle sicher, dass Handle mit @ beginnt (falls es keins ist)
        if (!identifier.startsWith('UC') && !identifier.startsWith('@')) {
            identifier = '@' + identifier;
        }
        
        const handle = identifier;
        console.log('🔍 DEBUG: Finaler Identifier:', handle);
        
        // LÖSCHE CACHE für diesen Handle (zum Debuggen)
        state.channels.delete(handle);
        state.channels.delete(handle.toLowerCase());
        console.log('🧹 Cache gelöscht für:', handle);
        
        const config = loadChannelConfig();
        
        // Prüfe auf Duplikat
        if (config.find(c => c.handle.toLowerCase() === handle.toLowerCase())) {
            showNotification('Dieser Kanal ist bereits vorhanden', 'error');
            return;
        }
        
        // Zeige Loading
        showStatus('Suche Kanal...', 'loading');
        
        // Wenn URL eingegeben wurde, versuche Channel-ID direkt zu extrahieren
        let channelId = null;
        if (input.includes('youtube.com/')) {
            try {
                console.log('🌐 Versuche Channel-ID von YouTube-Seite zu extrahieren...');
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(input);
                const response = await fetch(proxyUrl);
                const html = await response.text();
                
                // Suche nach Channel-ID in verschiedenen Formaten
                const patterns = [
                    /"channelId":"(UC[^"]+)"/,
                    /"externalId":"(UC[^"]+)"/,
                    /youtube\.com\/channel\/(UC[^"\/\?]+)/,
                    /"browse_id":"(UC[^"]+)"/
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match && match[1]) {
                        channelId = match[1];
                        console.log('✅ Channel-ID gefunden:', channelId);
                        break;
                    }
                }
            } catch (e) {
                console.warn('Channel-ID Extraktion fehlgeschlagen:', e);
            }
        }
        
        // Wenn wir eine Channel-ID haben, nutze diese direkt
        let info;
        if (channelId) {
            console.log('🎯 Verwende extrahierte Channel-ID:', channelId);
            info = await getChannelInfo(channelId);
        } else {
            // Fallback: Normale Suche
            info = await getChannelInfo(handle);
        }
        
        if (!info) {
            showNotification('Kanal nicht gefunden. Überprüfe den Namen.', 'error');
            return;
        }
        
        // Füge hinzu
        config.push({ handle: handle, isFavorite: false });
        saveChannelConfig(config);
        
        // Leere Input
        els.addChannelInput.value = '';
        
        // Rendere neu
        await renderChannelList();
        hideStatus();
        showNotification(`Kanal ${info.title} hinzugefügt ✓`, 'success');
        
        // Starte automatisch Daten-Aktualisierung für die Homepage
        console.log('🔄 Starte automatische Aktualisierung nach Kanal-Hinzufügung...');
        await forceUpdateAndCacheToFirebase();
    };

    // ===== UTILS & HELPERS =====
    const showStatus = (message, type = 'loading') => {
        els.statusBox.textContent = message;
        els.statusBox.className = type; // 'loading', 'success', 'error', 'info'
        
        // Auto-hide nach 5 Sekunden bei success/info, 8 Sekunden bei error
        if (type === 'success' || type === 'info') {
            setTimeout(() => hideStatus(), 5000);
        } else if (type === 'error') {
            setTimeout(() => hideStatus(), 8000);
        }
    };
    const hideStatus = () => { els.statusBox.className = 'hidden'; };
    
    // Elegante Alert-Alternative mit Glassmorphism
    const showNotification = (message, type = 'info') => {
        showStatus(message, type);
    };
    const fmtDate = s => new Date(s).toLocaleDateString('de-DE', { year: 'numeric', month: 'short', day: 'numeric' });
    const formatDuration = (seconds) => {
        if (!seconds) return '';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        const pad = n => n.toString().padStart(2, '0');
        return h > 0 ? `${h}:${pad(m)}:${pad(s)}` : `${m}:${pad(s)}`;
    };
    const parseISO8601Duration = (duration) => {
        if (!duration) return 0;
        const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
        if (!match) return 0;
        return (parseInt(match[1]) || 0) * 3600 + (parseInt(match[2]) || 0) * 60 + (parseInt(match[3]) || 0);
    };
    const delay = ms => new Promise(res => setTimeout(res, ms));
    
    // ===== RENDERERS =====
    const createSkeletonChannel = () => {
        const skeleton = document.createElement('div');
        skeleton.className = 'skeleton-card skeleton-channel';
        skeleton.innerHTML = `<div class="skeleton skeleton-thumb"></div><div class="skeleton skeleton-text"></div>`;
        return skeleton;
    };
    
    const createSkeletonVideo = () => {
        const skeleton = document.createElement('div');
        skeleton.className = 'skeleton-card skeleton-video';
        skeleton.innerHTML = `<div class="skeleton skeleton-thumb-rect"></div><div class="skeleton-body"><div class="skeleton skeleton-title"></div><div class="skeleton skeleton-meta"></div></div>`;
        return skeleton;
    };
    
    const showSkeletons = (container, count, type = 'video') => {
        container.innerHTML = '';
        for (let i = 0; i < count; i++) {
            container.appendChild(type === 'channel' ? createSkeletonChannel() : createSkeletonVideo());
        }
    };
    
    const renderChannelCard = (info, isFavorite) => {
        const card = document.createElement('div');
        card.className = 'chan-card';
        card.innerHTML = `<div class="chan-thumb"><img src="${info.thumb}" alt=""></div><div class="chan-meta"><div class="chan-title">${info.title}</div><div class="sub">Kanal öffnen</div></div>`;
        card.onclick = () => navigate(`channel/${info.id}/videos`);
        (isFavorite ? els.favoriteChannelGrid : els.otherChannelGrid).appendChild(card);
    };

    const videoCard = (v) => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.dataset.videoId = v.videoId;
        
        const progress = state.progressData.get(v.videoId);
        let progressPercent = progress?.duration > 0 ? Math.min((progress.currentTime / progress.duration) * 100, 100) : 0;
        const isWatched = progressPercent >= 90;

        const inMyList = state.myList?.has(v.videoId);
        
        card.innerHTML = `
            <div class="thumb">
                <img loading="lazy" src="${v.thumb || ''}" alt="">
                ${v.date ? `<span class="chip">${fmtDate(new Date(v.date))}</span>` : ''}
                <div class="progress-bar-container"><div class="progress-bar" style="width: ${progressPercent}%"></div></div>
                <button class="add-to-list-btn ${inMyList ? 'added' : ''}" title="Zu meiner Liste hinzufügen">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                    </svg>
                </button>
                <button class="mark-watched-btn ${isWatched ? 'watched' : ''}" title="Als angeschaut markieren">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
                    </svg>
                </button>
            </div>
            <div class="card-body">
                <div class="title">${v.title || '?'}</div>
                <div class="meta"><span>${v.channelTitle || 'Video'}</span><span>${formatDuration(v.durationSeconds)}</span></div>
            </div>`;
        
        const addBtn = card.querySelector('.add-to-list-btn');
        addBtn.onclick = (e) => {
            e.stopPropagation();
            toggleMyList(v);
        };
        
        const markBtn = card.querySelector('.mark-watched-btn');
        markBtn.onclick = (e) => {
            e.stopPropagation();
            markAsWatched(v.videoId, v.durationSeconds);
        };
        
        card.onclick = () => openPlayer(v.videoId, v.title); 
        return card;
    };
    
    const playlistCard = (p) => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.innerHTML = `<div class="thumb"><img loading="lazy" src="${p.thumb || ''}" alt="">${p.date ? `<span class="chip">${fmtDate(p.date)}</span>` : ''}</div><div class="card-body"><div class="title">${p.title || '?'}</div><div class="meta"><span>Playlist</span></div></div>`;
        card.onclick = () => openPlaylist(p.playlistId, p.title);
        return card;
    };

    const updateAllProgressBars = () => {
        document.querySelectorAll('.video-card[data-video-id]').forEach(card => {
            const videoId = card.dataset.videoId;
            const progress = state.progressData.get(videoId);
            const progressPercent = progress?.duration > 0 ? Math.min((progress.currentTime / progress.duration) * 100, 100) : 0;
            const bar = card.querySelector('.progress-bar');
            if (bar) bar.style.width = `${progressPercent}%`;
        });
    };

    // ===== DATA FETCHING & DATABASE =====
    const saveProgress = (videoId, currentTime, duration) => {
        if (!state.userId || !videoId || !isFinite(currentTime) || !isFinite(duration)) return;
        const data = { 
            currentTime: Math.round(currentTime), 
            duration: Math.round(duration), 
            lastWatched: firebase.firestore.FieldValue.serverTimestamp()
        };
        db.collection('users').doc(state.userId).collection('videoProgress').doc(videoId).set(data, { merge: true });
    };
    
    const markAsWatched = (videoId, duration) => {
        if (!state.userId || !videoId) {
            showNotification('Bitte melde dich an, um Videos als angeschaut zu markieren.', 'info');
            return;
        }
        // Setze Fortschritt auf 100%
        saveProgress(videoId, duration, duration);
        // Update UI sofort
        updateAllProgressBars();
        showNotification('Video als angeschaut markiert ✓', 'success');
    };

    const toggleMyList = async (video) => {
        if (!state.userId) {
            showNotification('Bitte melde dich an, um Videos zu deiner Liste hinzuzufügen.', 'info');
            return;
        }
        const videoId = video.videoId;
        if (state.myList.has(videoId)) {
            // Remove from list
            state.myList.delete(videoId);
            await firebase.firestore().collection('users').doc(state.userId).collection('myList').doc(videoId).delete();
            showNotification('Video von deiner Liste entfernt', 'info');
        } else {
            // Add to list
            state.myList.set(videoId, video);
            await firebase.firestore().collection('users').doc(state.userId).collection('myList').doc(videoId).set({
                videoId, title: video.title, thumb: video.thumb, channelTitle: video.channelTitle,
                durationSeconds: video.durationSeconds, date: video.date, addedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            showNotification('Video zu deiner Liste hinzugefügt ✓', 'success');
        }
        // Update UI
        document.querySelectorAll(`[data-video-id="${videoId}"] .add-to-list-btn`).forEach(btn => {
            btn.classList.toggle('added', state.myList.has(videoId));
        });
    };

    const loadMyList = async () => {
        if (!state.userId) return;
        const snapshot = await firebase.firestore().collection('users').doc(state.userId).collection('myList').get();
        state.myList.clear();
        snapshot.forEach(doc => {
            const data = doc.data();
            state.myList.set(data.videoId, data);
        });
    };

    const showMyListOverlay = () => {
        els.myListOverlay.classList.add('show');
        els.myListVideos.innerHTML = '';
        if (state.myList.size === 0) {
            els.myListVideos.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Deine Liste ist leer. Füge Videos mit dem Plus-Button hinzu!</p>';
            return;
        }
        state.myList.forEach(video => {
            els.myListVideos.appendChild(videoCard(video));
        });
    };

    const closeMyListOverlay = () => {
        els.myListOverlay.classList.remove('show');
    };

    const showContinueWatchingOverlay = () => {
        els.continueWatchingOverlay.classList.add('show');
        els.continueWatchingVideos.innerHTML = '';
        showSkeletons(els.continueWatchingVideos, 6, 'video');
        
        if (!state.userId) {
            els.continueWatchingVideos.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Bitte melde dich an.</p>';
            return;
        }
        
        firebase.firestore().collection('users').doc(state.userId).collection('videoProgress')
            .where('currentTime', '>', 0)
            .orderBy('currentTime', 'desc')
            .limit(20)
            .get()
            .then(async snapshot => {
                els.continueWatchingVideos.innerHTML = '';
                if (snapshot.empty) {
                    els.continueWatchingVideos.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Keine angefangenen Videos.</p>';
                    return;
                }
                const videoIds = snapshot.docs.map(d => d.id).filter(id => {
                    const progress = state.progressData.get(id);
                    return progress && progress.duration > 0 && (progress.currentTime / progress.duration) < 0.9;
                });
                
                if (videoIds.length === 0) {
                    els.continueWatchingVideos.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Keine angefangenen Videos.</p>';
                    return;
                }
                
                // Fetch video details from YouTube API
                const res = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${videoIds.join(',')}&key=${YOUTUBE_API_KEY}`);
                addQuotaCost('videos', videoIds.length); // +1 pro Video
                const data = await res.json();
                const videos = data.items.map(item => ({
                    videoId: item.id,
                    title: item.snippet.title,
                    thumb: item.snippet.thumbnails?.medium?.url,
                    channelTitle: item.snippet.channelTitle,
                    durationSeconds: parseISO8601Duration(item.contentDetails.duration),
                    date: item.snippet.publishedAt
                }));
                videos.forEach(v => els.continueWatchingVideos.appendChild(videoCard(v)));
            })
            .catch(e => {
                els.continueWatchingVideos.innerHTML = `<p style="color:var(--muted);padding:2rem;text-align:center;">Fehler: ${e.message}</p>`;
            });
    };

    const closeContinueWatchingOverlay = () => {
        els.continueWatchingOverlay.classList.remove('show');
    };

    const showContinueWatchingView = async () => {
        els.continueViewGrid.innerHTML = '';
        showSkeletons(els.continueViewGrid, 12, 'video');
        
        if (!state.userId) {
            els.continueViewGrid.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Bitte melde dich an.</p>';
            return;
        }
        
        try {
            const snapshot = await firebase.firestore().collection('users').doc(state.userId).collection('videoProgress')
                .where('currentTime', '>', 0)
                .orderBy('currentTime', 'desc')
                .limit(30)
                .get();
            
            els.continueViewGrid.innerHTML = '';
            if (snapshot.empty) {
                els.continueViewGrid.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Keine angefangenen Videos.</p>';
                return;
            }
            
            const videoIds = snapshot.docs.map(d => d.id).filter(id => {
                const progress = state.progressData.get(id);
                return progress && progress.duration > 0 && (progress.currentTime / progress.duration) < 0.9;
            });
            
            if (videoIds.length === 0) {
                els.continueViewGrid.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Keine angefangenen Videos.</p>';
                return;
            }
            
            // Fetch video details from YouTube API
            const res = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${videoIds.join(',')}&key=${YOUTUBE_API_KEY}`);
            addQuotaCost('videos', videoIds.length); // +1 pro Video
            const data = await res.json();
            const videos = data.items.map(item => ({
                videoId: item.id,
                title: item.snippet.title,
                thumb: item.snippet.thumbnails?.medium?.url,
                channelTitle: item.snippet.channelTitle,
                durationSeconds: parseISO8601Duration(item.contentDetails.duration),
                date: item.snippet.publishedAt
            }));
            videos.forEach(v => els.continueViewGrid.appendChild(videoCard(v)));
        } catch (e) {
            els.continueViewGrid.innerHTML = `<p style="color:var(--muted);padding:2rem;text-align:center;">Fehler: ${e.message}</p>`;
        }
    };

    const showMyListView = async () => {
        els.mylistViewGrid.innerHTML = '';
        showSkeletons(els.mylistViewGrid, 12, 'video');
        
        if (!state.userId) {
            els.mylistViewGrid.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Bitte melde dich an.</p>';
            return;
        }
        
        try {
            const snapshot = await firebase.firestore().collection('users').doc(state.userId).collection('myList')
                .orderBy('addedAt', 'desc')
                .limit(30)
                .get();
            
            els.mylistViewGrid.innerHTML = '';
            if (snapshot.empty) {
                els.mylistViewGrid.innerHTML = '<p style="color:var(--muted);padding:2rem;text-align:center;">Deine Liste ist leer. Füge Videos mit dem + Button hinzu.</p>';
                return;
            }
            
            const videoIds = snapshot.docs.map(d => d.id);
            
            // Fetch video details from YouTube API
            const res = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${videoIds.join(',')}&key=${YOUTUBE_API_KEY}`);
            addQuotaCost('videos', videoIds.length); // +1 pro Video
            const data = await res.json();
            const videos = data.items.map(item => ({
                videoId: item.id,
                title: item.snippet.title,
                thumb: item.snippet.thumbnails?.medium?.url,
                channelTitle: item.snippet.channelTitle,
                durationSeconds: parseISO8601Duration(item.contentDetails.duration),
                date: item.snippet.publishedAt
            }));
            videos.forEach(v => els.mylistViewGrid.appendChild(videoCard(v)));
        } catch (e) {
            els.mylistViewGrid.innerHTML = `<p style="color:var(--muted);padding:2rem;text-align:center;">Fehler: ${e.message}</p>`;
        }
    };

    const getChannelInfo = async (identifier) => {
        const isHandle = identifier.startsWith('@');
        const cleanHandle = isHandle ? identifier.replace(/^@+/, '') : null;

        const buildChannelInfo = (channel) => {
            const banner = channel.brandingSettings?.image?.bannerTvImageUrl?.replace(/=w\d+/, '=w2560') || null;
            const resolvedHandle = channel.snippet?.customUrl?.startsWith('@')
                ? channel.snippet.customUrl
                : (isHandle ? identifier : null);
            return {
                id: channel.id,
                title: channel.snippet?.title,
                thumb: channel.snippet?.thumbnails?.default?.url,
                uploadsId: channel.contentDetails?.relatedPlaylists?.uploads,
                banner,
                handle: resolvedHandle || null
            };
        };

        const cacheKeys = new Set([identifier]);
        if (isHandle) {
            cacheKeys.add(identifier.toLowerCase());
        }

        const saveToLocalCache = (info) => {
            cacheKeys.forEach(key => state.channels.set(key, info));
            state.channels.set(info.id, info);
            if (info.handle) {
                cacheKeys.add(info.handle);
                cacheKeys.add(info.handle.toLowerCase());
                state.channels.set(info.handle, info);
                state.channels.set(info.handle.toLowerCase(), info);
            }
        };

        const persistToFirebase = (info) => {
            channelInfoCacheRef.get().then(doc => {
                const existing = doc.exists ? doc.data().channels || {} : {};
                cacheKeys.forEach(key => existing[key] = info);
                existing[info.id] = info;
                if (info.handle) {
                    existing[info.handle] = info;
                    existing[info.handle.toLowerCase()] = info;
                }
                return channelInfoCacheRef.set({ channels: existing }, { merge: true });
            }).then(() => {
                console.log(`✅ Channel-Info in Firebase gespeichert: ${info.id}`);
            }).catch(e => console.error('Channel-Cache-Update fehlgeschlagen:', e));
        };

        // 1. Prüfe lokalen Cache
        if (state.channels.has(identifier)) {
            console.log(`📦 Channel-Info aus lokalem Cache: ${identifier}`);
            return state.channels.get(identifier);
        }
        if (isHandle && state.channels.has(identifier.toLowerCase())) {
            const cached = state.channels.get(identifier.toLowerCase());
            state.channels.set(identifier, cached);
            return cached;
        }

        let channelId = isHandle ? null : identifier;

        // 2. Handle via Suche auflösen (falls nötig)
        if (isHandle && !channelId) {
            console.log(`🔍 Suche Kanal für Handle: ${identifier}`);
            const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(identifier)}&type=channel&maxResults=10&key=${YOUTUBE_API_KEY}`);
            addQuotaCost('search'); // +100 Quota
            if (!res.ok) throw new Error('API Error beim Suchen');
            const searchData = await res.json();
            
            if (!searchData.items || searchData.items.length === 0) {
                throw new Error(`Kanal-Handle '${identifier}' nicht gefunden.`);
            }
            
            console.log(`🔍 Gefundene Kanäle:`, searchData.items.map(item => ({
                title: item.snippet?.channelTitle,
                id: item.snippet?.channelId
            })));
            
            // Hole alle Channel-IDs und deren Details um customUrl zu vergleichen
            const channelIds = searchData.items.map(item => item.snippet?.channelId).filter(Boolean).slice(0, 5);
            
            if (channelIds.length > 0) {
                const detailsRes = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails,brandingSettings&id=${channelIds.join(',')}&key=${YOUTUBE_API_KEY}`);
                addQuotaCost('channels'); // +1 Quota
                
                if (detailsRes.ok) {
                    const detailsData = await detailsRes.json();
                    
                    // Suche nach exakter Handle-Übereinstimmung
                    const exactMatch = detailsData.items?.find(ch => {
                        const customUrl = ch.snippet?.customUrl;
                        if (!customUrl) return false;
                        
                        const normalizedCustomUrl = customUrl.toLowerCase().replace(/^@/, '');
                        const normalizedInput = cleanHandle.toLowerCase();
                        
                        console.log(`Vergleiche: "${normalizedCustomUrl}" === "${normalizedInput}"`);
                        return normalizedCustomUrl === normalizedInput;
                    });
                    
                    if (exactMatch) {
                        console.log(`✅ Exakte Übereinstimmung gefunden: ${exactMatch.snippet?.title}`);
                        const info = buildChannelInfo(exactMatch);
                        saveToLocalCache(info);
                        persistToFirebase(info);
                        return info;
                    }
                    
                    // Falls keine exakte Übereinstimmung, versuche Title-Match
                    const titleMatch = detailsData.items?.find(ch => {
                        const title = ch.snippet?.title?.toLowerCase() || '';
                        const normalizedInput = cleanHandle.toLowerCase();
                        return title === normalizedInput || title.replace(/\s/g, '') === normalizedInput;
                    });
                    
                    if (titleMatch) {
                        console.log(`✅ Title-Match gefunden: ${titleMatch.snippet?.title}`);
                        const info = buildChannelInfo(titleMatch);
                        saveToLocalCache(info);
                        persistToFirebase(info);
                        return info;
                    }
                    
                    // Letzter Fallback: nimm den ersten
                    console.warn(`⚠️ Keine exakte Übereinstimmung, verwende ersten Treffer`);
                    if (detailsData.items?.[0]) {
                        const info = buildChannelInfo(detailsData.items[0]);
                        saveToLocalCache(info);
                        persistToFirebase(info);
                        return info;
                    }
                }
            }
            
            throw new Error(`Kanal-Handle '${identifier}' konnte nicht aufgelöst werden.`);
        }

        // 4. Prüfe Firebase Cache
        try {
            const cacheDoc = await channelInfoCacheRef.get();
            if (cacheDoc.exists) {
                const channelsCache = cacheDoc.data().channels || {};
                const cached = channelsCache[channelId] || channelsCache[identifier] || (isHandle ? channelsCache[identifier.toLowerCase()] : null);
                if (cached) {
                    console.log(`🔥 Channel-Info aus Firebase Cache: ${channelId || identifier}`);
                    saveToLocalCache(cached);
                    return cached;
                }
            }
        } catch (e) {
            console.warn('Firebase Cache-Check fehlgeschlagen:', e);
        }

        if (!channelId) {
            throw new Error(`Kanal konnte nicht aufgelöst werden: ${identifier}`);
        }

        // 5. API-Call (nur wenn wirklich nicht gecacht)
        console.log(`🌐 Lade Channel-Info von API: ${channelId}`);
        const res = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails,brandingSettings&id=${channelId}&key=${YOUTUBE_API_KEY}`);
        addQuotaCost('channels'); // +1 Quota
        if (!res.ok) throw new Error('API Error');
        const data = await res.json();
        const channel = data.items?.[0];
        if (!channel) throw new Error(`Kanal-Info für ID ${channelId} nicht gefunden.`);

        const info = buildChannelInfo(channel);
        saveToLocalCache(info);
        persistToFirebase(info);
        return info;
    };
    
    const enrichVideosWithDuration = async (items, idKey) => {
        if (!items || items.length === 0) return [];
        const getVideoId = (item, key) => (key === 'id' ? item.id?.videoId : item.snippet?.resourceId?.videoId);
        
        const allVideoIds = items.map(it => getVideoId(it, idKey)).filter(Boolean);
        if (allVideoIds.length === 0) return [];

        const durationMap = new Map();
        const newCacheEntries = {}; // Neue Videos zum Speichern
        
        for (let i = 0; i < allVideoIds.length; i += 50) {
            const chunk = allVideoIds.slice(i, i + 50);
            
            // Prüfe erst den Cache
            const uncachedIds = [];
            chunk.forEach(videoId => {
                if (state.videoDetailsCache.has(videoId)) {
                    durationMap.set(videoId, state.videoDetailsCache.get(videoId).durationSeconds);
                } else {
                    uncachedIds.push(videoId);
                }
            });
            
            // Nur API-Call für nicht-gecachte Videos
            if (uncachedIds.length > 0) {
                const res = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=contentDetails&id=${uncachedIds.join(',')}&key=${YOUTUBE_API_KEY}`);
                addQuotaCost('videos', uncachedIds.length); // +1 pro Video
                if (res.ok) {
                    const data = await res.json();
                    data.items.forEach(v => {
                        const duration = parseISO8601Duration(v.contentDetails.duration);
                        durationMap.set(v.id, duration);
                        
                        // Speichere in lokalem Cache
                        const cacheEntry = { durationSeconds: duration };
                        state.videoDetailsCache.set(v.id, cacheEntry);
                        newCacheEntries[v.id] = cacheEntry;
                    });
                }
            }
        }
        
        // Speichere neue Einträge in Firebase (async, blockiert nicht)
        if (Object.keys(newCacheEntries).length > 0) {
            videoDetailsCacheRef.get().then(doc => {
                const existing = doc.exists ? doc.data().videos || {} : {};
                const updated = { ...existing, ...newCacheEntries };
                return videoDetailsCacheRef.set({ videos: updated }, { merge: true });
            }).catch(e => console.error('Cache-Update fehlgeschlagen:', e));
        }
        
        return items
            .map(item => ({ ...item, durationSeconds: durationMap.get(getVideoId(item, idKey)) || 0 }))
            .filter(item => {
                const duration = item.durationSeconds || 0;
                // If duration is 0, it's likely a live stream or premiere, keep it.
                if (duration === 0) return true;
                return duration >= state.settings.minDuration;
            });
    };

    const setupProgressListener = () => {
        if (state.progressListenerUnsubscribe) state.progressListenerUnsubscribe();
        if (!state.userId) return;

        state.progressListenerUnsubscribe = db.collection('users').doc(state.userId).collection('videoProgress')
            .orderBy('lastWatched', 'desc')
            .onSnapshot(snapshot => {
                const newProgress = new Map();
                snapshot.forEach(doc => newProgress.set(doc.id, doc.data()));
                state.progressData = newProgress;
                updateAllProgressBars();
            }, console.error);
    };

    // ===== FIREBASE CACHE & HOMEPAGE LOGIC =====
    const renderHomeFromFirebase = (data) => {
        if (!data || !data.channels || !data.videos) {
            showStatus('Cache leer. Klicke auf "🔄", um Daten zu laden.');
            return;
        }
        const { channels, videos } = data;
        els.favoriteChannelGrid.innerHTML = ''; els.otherChannelGrid.innerHTML = ''; els.latestVideosGrid.innerHTML = '';
        channels.forEach(ch => renderChannelCard(ch, ch.isFavorite));
        videos.forEach(v => els.latestVideosGrid.appendChild(videoCard(v)));
        updateAllProgressBars();
    };

    const forceUpdateAndCacheToFirebase = async () => {
        els.refreshBtn.classList.add('loading');
        showStatus('Aktualisiere Daten von YouTube...');
        showSkeletons(els.favoriteChannelGrid, 4, 'channel');
        showSkeletons(els.otherChannelGrid, 7, 'channel');
        showSkeletons(els.latestVideosGrid, 8, 'video');
        
        const channelsConfig = loadChannelConfig();
        const successfulChannels = [];
        for (const config of channelsConfig) {
            try {
                const info = await getChannelInfo(config.handle);
                successfulChannels.push({ ...info, isFavorite: config.isFavorite });
                await delay(100); 
            } catch (e) { console.error(`Konnte Kanal-Info für ${config.handle} nicht laden:`, e); }
        }
        
        const latestVideoItems = [];
        for (const info of successfulChannels) {
            try {
                const res = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${info.uploadsId}&maxResults=5&key=${YOUTUBE_API_KEY}`);
                addQuotaCost('playlistItems'); // +1 Quota
                if (res.ok) {
                    const data = await res.json();
                    if(data.items?.length > 0) {
                        const enriched = await enrichVideosWithDuration(data.items, 'snippet');
                        if (enriched.length > 0) {
                            latestVideoItems.push({...enriched[0], channelTitle: info.title});
                        }
                    }
                }
                await delay(100); 
            } catch (e) { console.error(`Konnte Videos für ${info.title} nicht laden:`, e); }
        }

        const allVideos = latestVideoItems.map(it => ({
            videoId: it.snippet.resourceId.videoId, title: it.snippet.title,
            date: it.snippet.publishedAt, thumb: it.snippet.thumbnails?.medium?.url,
            channelId: it.snippet.channelId, channelTitle: it.channelTitle,
            durationSeconds: it.durationSeconds
        }));
        
        allVideos.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        const cacheData = { channels: successfulChannels, videos: allVideos, timestamp: firebase.firestore.FieldValue.serverTimestamp() };
        await homeCacheRef.set(cacheData);
        showStatus('Daten erfolgreich aktualisiert ✓', 'success');
        els.refreshBtn.classList.remove('loading');
    };

    // ===== NAVIGATION & ROUTING =====
    const navigate = hash => window.location.hash = hash;
    const parseRoute = () => {
        const h = window.location.hash.slice(1) || 'home';
        const parts = h.split('/');
        return { view: parts[0], id: parts[1], tab: parts[2] };
    };
    const setView = name => {
        ['homeView', 'channelView', 'privacyView', 'termsView', 'settingsView', 'continueView', 'mylistView'].forEach(viewId => {
            if (els[viewId]) els[viewId].classList.add('hidden');
        });
        if (els[name + 'View']) els[name + 'View'].classList.remove('hidden');
    };
    
    const openPlayer = (videoId, title) => {
        els.playerTitle.textContent = title || 'Video';
        els.overlay.classList.add('show');
        const progress = state.progressData.get(videoId);
        
        state.current.player = new YT.Player('player-mount', {
            height: '100%', width: '100%', videoId,
            playerVars: { 'playsinline': 1, 'autoplay': 1, 'rel': 0, 'start': progress?.currentTime || 0 },
            events: { 'onStateChange': onPlayerStateChange }
        });
    };
    
    const onPlayerStateChange = event => {
        clearInterval(state.current.playerStateInterval);
        if (event.data !== YT.PlayerState.PLAYING) return;
        
        const player = event.target;
        const videoId = player.getVideoData().video_id;
        state.current.playerStateInterval = setInterval(() => {
            const currentTime = player.getCurrentTime();
            const duration = player.getDuration();
            if (currentTime > 0 && duration > 0) saveProgress(videoId, currentTime, duration);
        }, 3000);
    };

    const closePlayer = () => {
        clearInterval(state.current.playerStateInterval);
        if (state.current.player?.destroy) state.current.player.destroy();
        state.current.player = null;
        els.overlay.classList.remove('show');
    };
    
    const openPlaylist = async (playlistId, title) => {
        els.playlistTitle.textContent = title || 'Playlist';
        els.playlistOverlay.classList.add('show');
        els.playlistVideos.innerHTML = '';
        showSkeletons(els.playlistVideos, 8, 'video');
        
        try {
            const params = new URLSearchParams({ 
                key: YOUTUBE_API_KEY, part: 'snippet', 
                playlistId, maxResults: 20 
            });
            const res = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?${params}`);
            addQuotaCost('playlistItems'); // +1 Quota
            if (!res.ok) throw new Error('Fehler beim Laden der Playlist');
            const data = await res.json();
            
            let items = (data.items || []).filter(it => it.snippet?.thumbnails);
            items = await enrichVideosWithDuration(items, 'snippet');
            
            els.playlistVideos.innerHTML = '';
            items.forEach(it => {
                const v = {
                    videoId: it.snippet.resourceId.videoId,
                    title: it.snippet.title,
                    date: it.snippet.publishedAt,
                    thumb: it.snippet.thumbnails?.medium?.url,
                    channelTitle: it.snippet.channelTitle,
                    durationSeconds: it.durationSeconds
                };
                els.playlistVideos.appendChild(videoCard(v));
            });
        } catch(e) {
            els.playlistVideos.innerHTML = `<p style="color:var(--muted);padding:2rem;text-align:center;">Fehler: ${e.message}</p>`;
        }
    };
    
    const closePlaylist = () => {
        els.playlistOverlay.classList.remove('show');
    };
    
    const handleRoute = async () => {
        const r = parseRoute();
        hideStatus();
        // Close side menu on navigation
        els.sideMenu.classList.remove('open');
        els.menuOverlay.classList.add('hidden');
        try {
            if (['home', 'privacy', 'terms', 'settings'].includes(r.view)) {
                setView(r.view);
                if (r.view === 'settings') {
                    renderChannelList();
                }
            } else if (r.view === 'continue') {
                setView('continue');
                await showContinueWatchingView();
            } else if (r.view === 'mylist') {
                setView('mylist');
                await showMyListView();
            } else if (r.view === 'channel' && r.id) {
                setView('channel'); 
                state.current.channelId = r.id; 
                state.current.tab = r.tab || 'videos';
                els.tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === state.current.tab));
                const info = await getChannelInfo(r.id);
                els.channelName.textContent = info.title;
                els.channelBannerContainer.classList.toggle('hidden', !info.banner);
                if (info.banner) {
                    els.channelBannerBackground.style.backgroundImage = `url(${info.banner})`;
                }
                await showChannelContent(state.current.tab, { reset: true });
            } else { 
                navigate('home'); 
            }
        } catch (e) { console.error(`Fehler bei Navigation:`, e); showStatus(e.message, 'error'); }
    };
    
    const showChannelContent = async (type, { reset = true } = {}) => {
        const isVideos = type === 'videos';
        const tabEl = isVideos ? els.videosTab : els.playlistsTab;
        const otherTabEl = isVideos ? els.playlistsTab : els.videosTab;
        const moreBtn = isVideos ? els.moreVideosBtn : els.morePlaylistsBtn;
        
        els.moreVideosBtn.classList.add('hidden'); els.morePlaylistsBtn.classList.add('hidden');
        const pageTokenKey = isVideos ? 'videosPageToken' : 'playlistsPageToken';
        if (reset) { 
            showSkeletons(tabEl, 12, 'video');
            state.current[pageTokenKey] = null; 
        }
        showStatus(`Lade ${type}...`);
        tabEl.classList.remove('hidden'); otherTabEl.classList.add('hidden');
        try {
            const info = await getChannelInfo(state.current.channelId);
            const endpoint = isVideos ? 'playlistItems' : 'playlists';
            const params = new URLSearchParams({ key: YOUTUBE_API_KEY, part: 'snippet', maxResults: 15 });
            if(isVideos) params.set('playlistId', info.uploadsId);
            else params.set('channelId', state.current.channelId);
            if (state.current[pageTokenKey]) params.set('pageToken', state.current[pageTokenKey]);

            const res = await fetch(`https://www.googleapis.com/youtube/v3/${endpoint}?${params}`);
            addQuotaCost(isVideos ? 'playlistItems' : 'playlists'); // +1 Quota
            if (!res.ok) throw new Error('API-Fehler beim Laden von Inhalten');
            const data = await res.json();
            
            state.current[pageTokenKey] = data.nextPageToken || null;
            let items = (data.items || []).filter(it => it.snippet?.thumbnails);
            if (isVideos) items = await enrichVideosWithDuration(items, 'snippet');
            
            // Skeletons entfernen bevor echte Daten angezeigt werden
            if (reset) tabEl.innerHTML = '';
            
            items.forEach(it => {
                if (isVideos) {
                    tabEl.appendChild(videoCard({ videoId: it.snippet.resourceId.videoId, title: it.snippet.title, date: it.snippet.publishedAt, thumb: it.snippet.thumbnails?.medium?.url, channelTitle: info.title, durationSeconds: it.durationSeconds }));
                } else {
                    tabEl.appendChild(playlistCard({ playlistId: it.id, channelId: state.current.channelId, title: it.snippet.title, date: it.snippet.publishedAt, thumb: it.snippet.thumbnails?.medium?.url, channelTitle: info.title }));
                }
            });
            moreBtn.classList.toggle('hidden', !state.current[pageTokenKey]);
            hideStatus();
        } catch(e) { showStatus(`Fehler beim Laden von ${type}: ${e.message}`, 'error'); }
    };
    
    const searchInChannel = async () => {
        const q = els.searchInput.value.trim();
        if (!q) {
            clearSearch();
            return;
        }
        
        // Zeige Kreuz-Button
        els.clearSearchBtn.classList.remove('hidden');
        
        // Bestimme aktuellen Tab
        const isVideos = state.current.tab === 'videos';
        const searchType = isVideos ? 'video' : 'playlist';
        const targetTab = isVideos ? els.videosTab : els.playlistsTab;
        
        els.sortOptions.classList.remove('hidden');
        document.querySelectorAll('[data-sort]').forEach(btn => btn.classList.toggle('active', btn.dataset.sort === state.current.searchOrder));
        showStatus(`Suche nach "${q}"...`);
        targetTab.innerHTML = '';
        
        try {
            const params = new URLSearchParams({ 
                key: YOUTUBE_API_KEY, 
                part: 'snippet', 
                maxResults: 25, 
                channelId: state.current.channelId, 
                q: `"${q}"`, 
                type: searchType, 
                order: state.current.searchOrder 
            });
            const res = await fetch(`https://www.googleapis.com/youtube/v3/search?${params}`);
            addQuotaCost('search'); // +100 Quota
            if(!res.ok) throw new Error('API-Fehler bei der Suche');
            const data = await res.json();
            
            const info = await getChannelInfo(state.current.channelId);
            
            if (isVideos) {
                // Videos durchsuchen
                let items = await enrichVideosWithDuration(data.items || [], 'id');
                items.forEach(it => {
                    targetTab.appendChild(videoCard({ 
                        videoId: it.id.videoId, 
                        title: it.snippet.title, 
                        date: it.snippet.publishedAt, 
                        thumb: it.snippet.thumbnails.medium.url, 
                        channelTitle: info.title, 
                        durationSeconds: it.durationSeconds 
                    }));
                });
            } else {
                // Playlists durchsuchen
                (data.items || []).forEach(it => {
                    targetTab.appendChild(playlistCard({ 
                        playlistId: it.id.playlistId, 
                        channelId: state.current.channelId,
                        title: it.snippet.title, 
                        date: it.snippet.publishedAt, 
                        thumb: it.snippet.thumbnails?.medium?.url, 
                        channelTitle: info.title 
                    }));
                });
            }
            
            hideStatus();
        } catch(e) { showStatus(`Suche fehlgeschlagen: ${e.message}`, 'error'); }
    };
    
    const clearSearch = () => {
        els.searchInput.value = '';
        els.clearSearchBtn.classList.add('hidden');
        els.sortOptions.classList.add('hidden');
        showChannelContent('videos', { reset: true });
    };

    // ===== THEME SYSTEM =====
    const applyTheme = () => {
        if (state.theme === 'light') {
            document.body.classList.remove('text-dark');
            document.body.classList.add('text-light');
            document.body.style.backgroundColor = '#f5f5f5';
        } else {
            document.body.classList.remove('text-light');
            document.body.classList.add('text-dark');
            document.body.style.backgroundColor = '#0f0f0f';
        }
        localStorage.setItem('theme', state.theme);
    };
    
    const toggleTheme = () => {
        state.theme = state.theme === 'dark' ? 'light' : 'dark';
        applyTheme();
    };
    
    const loadTheme = () => {
        const saved = localStorage.getItem('theme');
        if (saved) state.theme = saved;
        applyTheme();
    };
    
    // ===== BACKGROUND IMAGE =====
    const applyBgImage = () => {
        if (state.bgImage) {
            document.body.classList.add('has-bg-image');
            document.body.style.setProperty('--bg-image', `url(${state.bgImage})`);
            els.bgPreview.style.backgroundImage = `url(${state.bgImage})`;
            els.bgPreview.classList.remove('hidden');
        } else {
            document.body.classList.remove('has-bg-image');
            document.body.style.removeProperty('--bg-image');
            els.bgPreview.classList.add('hidden');
        }
    };
    
    const loadBgImage = async () => {
        if (!state.userId) {
            console.log('Kein User angemeldet - Hintergrundbild kann nicht geladen werden');
            return;
        }
        
        console.log('Lade Hintergrundbild für User:', state.userId);
        try {
            const doc = await db.collection('users').doc(state.userId).collection('settings').doc('background').get();
            console.log('Firebase Dokument exists:', doc.exists);
            
            if (doc.exists) {
                const data = doc.data();
                console.log('Firebase Daten:', data);
                
                if (data && data.imageUrl) {
                    state.bgImage = data.imageUrl;
                    applyBgImage();
                    console.log('✅ Hintergrundbild erfolgreich geladen! Größe:', (data.imageUrl.length / 1024).toFixed(2), 'KB');
                } else {
                    console.log('⚠️ Dokument existiert, aber imageUrl ist leer');
                }
            } else {
                console.log('ℹ️ Kein gespeichertes Hintergrundbild gefunden');
            }
        } catch (err) {
            console.error('❌ Fehler beim Laden des Hintergrundbilds:', err);
        }
    };
    
    const saveBgImage = async () => {
        if (!state.userId) {
            console.warn('❌ Kein User angemeldet - Hintergrundbild nicht gespeichert');
            showStatus('Bitte melde dich an, um das Hintergrundbild zu speichern', 'error');
            return;
        }
        
        console.log('Speichere Hintergrundbild für User:', state.userId);
        console.log('Bildgröße:', state.bgImage ? (state.bgImage.length / 1024).toFixed(2) + ' KB' : 'null');
        
        try {
            const docRef = db.collection('users').doc(state.userId).collection('settings').doc('background');
            
            // WICHTIG: Erst das alte Dokument komplett löschen
            console.log('🗑️ Lösche altes Dokument...');
            try {
                await docRef.delete();
                console.log('✅ Altes Dokument gelöscht');
            } catch (deleteErr) {
                console.log('ℹ️ Kein altes Dokument zum Löschen (ist okay)');
            }
            
            // Warte kurz (Firestore Delay)
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Jetzt das neue Bild speichern
            console.log('💾 Speichere neues Bild...');
            await docRef.set({
                imageUrl: state.bgImage || null,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            console.log('✅ Hintergrundbild erfolgreich in Firebase gespeichert!');
            showStatus('Hintergrundbild gespeichert!');
            
            // Verifizierung: Lade das Bild direkt wieder
            await new Promise(resolve => setTimeout(resolve, 200));
            const verifyDoc = await docRef.get();
            if (verifyDoc.exists) {
                console.log('✅ Verifizierung: Dokument existiert in Firebase');
                const verifyData = verifyDoc.data();
                if (verifyData && verifyData.imageUrl) {
                    console.log('✅ Verifizierung: imageUrl ist vorhanden, Größe:', (verifyData.imageUrl.length / 1024).toFixed(2), 'KB');
                } else {
                    console.warn('⚠️ Verifizierung: imageUrl ist leer!');
                }
            }
        } catch (err) {
            console.error('❌ Fehler beim Speichern des Hintergrundbilds:', err);
            showStatus('Fehler beim Speichern des Hintergrundbilds', 'error');
        }
    };
    
    const compressImage = (file, maxSizeKB = 800) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Maximale Breite: 1920px (Full HD ist genug für Hintergrundbild)
                    let width = img.width;
                    let height = img.height;
                    const maxWidth = 1920;
                    
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Starte mit Qualität 0.9 und reduziere bei Bedarf
                    let quality = 0.9;
                    let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log('🔄 Komprimiere Bild... Qualität:', quality, 'Größe:', (compressedDataUrl.length / 1024).toFixed(2), 'KB');
                    
                    // Reduziere Qualität bis die Größe passt (max 800KB für Firebase-Limit von 1MB)
                    while (compressedDataUrl.length / 1024 > maxSizeKB && quality > 0.3) {
                        quality -= 0.1;
                        compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        console.log('🔄 Reduziere Qualität auf', quality.toFixed(1), '→ Größe:', (compressedDataUrl.length / 1024).toFixed(2), 'KB');
                    }
                    
                    if (compressedDataUrl.length / 1024 > maxSizeKB) {
                        reject(new Error('Bild konnte nicht ausreichend komprimiert werden'));
                    } else {
                        console.log('✅ Komprimierung abgeschlossen! Finale Größe:', (compressedDataUrl.length / 1024).toFixed(2), 'KB, Qualität:', quality.toFixed(1));
                        resolve(compressedDataUrl);
                    }
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    };
    
    const handleBgImageUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) {
            console.log('Kein Bild ausgewählt');
            return;
        }
        
        console.log('📸 Bild ausgewählt:', file.name, 'Größe:', (file.size / 1024).toFixed(2), 'KB');
        
        if (!state.userId) {
            console.warn('❌ Kein User angemeldet');
            showStatus('Bitte melde dich an, um das Hintergrundbild zu speichern', 'error');
            return;
        }
        
        console.log('✅ User angemeldet:', state.userId);
        
        // Maximale Dateigröße: 10MB (wir komprimieren es eh)
        if (file.size > 10 * 1024 * 1024) {
            alert('Das Bild ist zu groß. Maximal 10MB erlaubt.');
            return;
        }
        
        try {
            showStatus('Komprimiere Bild...');
            console.log('🔄 Starte Bildkomprimierung...');
            
            // Komprimiere das Bild auf max 800KB (Firebase Limit ist 1MB)
            const compressedImage = await compressImage(file, 800);
            
            console.log('✅ Bild komprimiert, Base64 Größe:', (compressedImage.length / 1024).toFixed(2), 'KB');
            state.bgImage = compressedImage;
            console.log('✅ state.bgImage gesetzt');
            applyBgImage();
            console.log('✅ Bild angewendet, starte Speicherung...');
            await saveBgImage();
            console.log('✅ Upload-Prozess abgeschlossen!');
            
            // Reset File Input für nächsten Upload
            e.target.value = '';
        } catch (err) {
            console.error('❌ Fehler beim Verarbeiten des Bildes:', err);
            showStatus('Fehler beim Komprimieren des Bildes', 'error');
        }
    };
    
    const removeBgImage = async () => {
        console.log('🗑️ Lösche Hintergrundbild...');
        state.bgImage = null;
        applyBgImage();
        
        if (state.userId) {
            try {
                // Lösche das komplette Dokument (nicht nur den Wert)
                await db.collection('users').doc(state.userId).collection('settings').doc('background').delete();
                console.log('✅ Hintergrundbild-Dokument komplett aus Firebase gelöscht');
                showStatus('Hintergrundbild entfernt');
            } catch (err) {
                console.error('❌ Fehler beim Löschen:', err);
            }
        }
    };
    
    // DEBUG: Temporäre Funktion zum Zurücksetzen des Hintergrundbilds
    window.resetBgImage = async () => {
        if (!state.userId) {
            console.error('❌ Nicht angemeldet');
            alert('Bitte melde dich erst an!');
            return;
        }
        
        console.log('🔄 RESET: Lösche altes Hintergrundbild komplett...');
        try {
            const docRef = db.collection('users').doc(state.userId).collection('settings').doc('background');
            await docRef.delete();
            console.log('✅ Dokument gelöscht');
            
            state.bgImage = null;
            applyBgImage();
            console.log('✅ State und UI zurückgesetzt');
            
            alert('✅ Hintergrundbild komplett zurückgesetzt! Jetzt kannst du ein neues hochladen.');
        } catch (err) {
            console.error('❌ Fehler:', err);
            alert('Fehler beim Zurücksetzen: ' + err.message);
        }
    };

    // ===== EVENT LISTENERS =====
    const setupEventListeners = () => {
        window.onhashchange = handleRoute;
        els.homeBtn.onclick = () => navigate('home');
        els.refreshBtn.onclick = forceUpdateAndCacheToFirebase;
        els.backBtn.onclick = () => history.back();
        els.forwardBtn.onclick = () => history.forward();
        els.playerClose.onclick = closePlayer;
        els.playlistClose.onclick = closePlaylist;
        els.playlistOverlay.onclick = (e) => { if (e.target === els.playlistOverlay) closePlaylist(); };
        els.myListClose.onclick = closeMyListOverlay;
        els.myListOverlay.onclick = (e) => { if (e.target === els.myListOverlay) closeMyListOverlay(); };
        els.myListLink.onclick = (e) => { 
            e.preventDefault(); 
            els.sideMenu.classList.remove('open');
            els.menuOverlay.classList.add('hidden');
            navigate('mylist'); 
        };
        els.continueWatchingClose.onclick = closeContinueWatchingOverlay;
        els.continueWatchingOverlay.onclick = (e) => { if (e.target === els.continueWatchingOverlay) closeContinueWatchingOverlay(); };
        els.continueWatchingLink.onclick = (e) => { 
            e.preventDefault(); 
            els.sideMenu.classList.remove('open');
            els.menuOverlay.classList.add('hidden');
            navigate('continue'); 
        };
        els.themeToggleBtn.onclick = toggleTheme;

        els.durationPlusBtn.onclick = () => {
            state.settings.minDuration += 30;
            applySettings();
            saveSettings();
        };

        els.durationMinusBtn.onclick = () => {
            state.settings.minDuration = Math.max(0, state.settings.minDuration - 30);
            applySettings();
            saveSettings();
        };
        
        els.bgImageBtn.onclick = () => els.bgImageInput.click();
        els.bgImageInput.onchange = handleBgImageUpload;
        els.bgImageRemoveBtn.onclick = removeBgImage;
        
        // Channel Management
        els.addChannelBtn.onclick = addNewChannel;
        els.addChannelInput.onkeydown = e => { if (e.key === 'Enter') addNewChannel(); };
        
        els.overlay.onclick = e => { if (e.target === els.overlay) closePlayer(); };
        els.menuBtn.onclick = () => {
            els.sideMenu.classList.toggle('open');
            els.menuOverlay.classList.toggle('hidden');
        };
        els.menuOverlay.onclick = () => {
            els.sideMenu.classList.remove('open');
            els.menuOverlay.classList.add('hidden');
        };
        els.sideMenu.addEventListener('mouseleave', () => {
            els.sideMenu.classList.remove('open');
            els.menuOverlay.classList.add('hidden');
        });
        els.tabs.forEach(btn => btn.onclick = () => navigate(`channel/${state.current.channelId}/${btn.dataset.tab}`));
        els.moreVideosBtn.onclick = () => showChannelContent('videos', { reset: false });
        els.morePlaylistsBtn.onclick = () => showChannelContent('playlists', { reset: false });
        els.searchBtn.onclick = searchInChannel;
        els.clearSearchBtn.onclick = clearSearch;
        els.searchInput.onkeydown = e => { if (e.key === 'Enter') searchInChannel(); };
        document.querySelectorAll('[data-sort]').forEach(btn => btn.onclick = () => {
            state.current.searchOrder = btn.dataset.sort;
            searchInChannel();
        });
        
        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            // ESC zum Schließen des Players
            if (e.key === 'Escape' && els.overlay.classList.contains('show')) {
                closePlayer();
                e.preventDefault();
            }
            
            // Keyboard-Shortcuts nur wenn kein Input fokussiert ist
            if (document.activeElement.tagName === 'INPUT') return;
            
            // Leertaste zum Pausieren/Fortsetzen (nur wenn Player offen)
            if (e.key === ' ' && state.current.player && els.overlay.classList.contains('show')) {
                const playerState = state.current.player.getPlayerState();
                if (playerState === YT.PlayerState.PLAYING) {
                    state.current.player.pauseVideo();
                } else if (playerState === YT.PlayerState.PAUSED) {
                    state.current.player.playVideo();
                }
                e.preventDefault();
            }
            
            // Pfeiltasten zum Vor-/Zurückspulen (nur wenn Player offen)
            if (state.current.player && els.overlay.classList.contains('show')) {
                if (e.key === 'ArrowLeft') {
                    const currentTime = state.current.player.getCurrentTime();
                    state.current.player.seekTo(Math.max(0, currentTime - 10), true);
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    const currentTime = state.current.player.getCurrentTime();
                    const duration = state.current.player.getDuration();
                    state.current.player.seekTo(Math.min(duration, currentTime + 10), true);
                    e.preventDefault();
                }
            }
        });
    };

    // ===== APP INITIALIZATION & AUTH =====
    const initAuth = () => {
        els.authBtn.onclick = () => {
            if (state.user) auth.signOut();
            else auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()).catch(err => showStatus(`Anmeldung fehlgeschlagen: ${err.message}`, 'error'));
        };
        auth.onAuthStateChanged(user => {
            const wasLoggedIn = !!state.user;
            state.user = user; state.userId = user?.uid;
            
            console.log('🔐 Auth State Changed:', user ? `Angemeldet als ${user.displayName} (${user.uid})` : 'Abgemeldet');
            
            els.authBtn.textContent = user ? 'Abmelden' : 'Anmelden';
            els.userAvatar.classList.toggle('hidden', !user);
            els.userName.textContent = user ? user.displayName : '';
            if (user) els.userAvatar.src = user.photoURL;

            if (user) {
                console.log('✅ User angemeldet - lade Daten...');
                setupProgressListener();
                loadBgImage();
                loadMyList();
            } else {
                if (state.progressListenerUnsubscribe) state.progressListenerUnsubscribe();
                state.progressData.clear();
                state.myList.clear();
                updateAllProgressBars();
                state.bgImage = null;
                applyBgImage();
            }
            if (!!user !== wasLoggedIn || !wasLoggedIn) handleRoute();
        });
    };
    
    loadSettings();
    loadQuotaState();
    state.channelsConfig = loadChannelConfig();
    setupEventListeners();
    loadTheme();
    applySettings();
    homeCacheRef.onSnapshot(doc => {
        if (doc.exists) {
            renderHomeFromFirebase(doc.data());
        } else {
            showStatus('Cache leer. Klicke auf "🔄", um die Daten erstmalig zu laden.');
        }
    }, console.error);
    videoDetailsCacheRef.get().then(doc => {
        if(doc.exists) {
            const data = doc.data();
            for(const key in data.videos) {
                state.videoDetailsCache.set(key, data.videos[key]);
            }
            console.log(`📦 ${Object.keys(data.videos || {}).length} Video-Details aus Firebase geladen`);
        }
    });
    
    // Channel-Info Cache beim Start laden
    channelInfoCacheRef.get().then(doc => {
        if(doc.exists) {
            const data = doc.data();
            let count = 0;
            for(const key in data.channels) {
                state.channels.set(key, data.channels[key]);
                count++;
            }
            console.log(`📦 ${count} Channel-Infos aus Firebase geladen`);
        }
    }).catch(e => console.warn('Channel-Cache laden fehlgeschlagen:', e));
    
    window.addEventListener('youtube-api-ready', initAuth);
});
</script>

</body>
</html>

